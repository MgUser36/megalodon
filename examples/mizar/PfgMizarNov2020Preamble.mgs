(* Parameter the "174b78e53fc239e8c2aab4ab5a996a27e3e5741e88070dad186e05fb13f275e5" *)
Parameter the : (set->prop)->set.

Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).

(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.

Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.

Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.

Section FE.
Variable A B : SType.
Axiom func_ext : forall f g : A -> B , (forall x : A , f x = g x) -> f = g.
End FE.

Axiom f_eq_i : forall f:set -> set, forall x y, x = y -> f x = f y.
Axiom f_eq_i_i : forall f:set -> set -> set, forall x y z w, x = y -> z = w -> f x z = f y w.
Axiom eq_i_tra : forall x y z, x = y -> y = z -> x = z.

Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.

(* Unicode exists "2203" *)
Binder+ exists , := ex.

Axiom prop_ext : forall p q:prop, iff p q -> p = q.

Parameter In:set->set->prop.

Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.

Definition nSubq : set->set->prop :=
fun X Y => ~Subq X Y.

(* Unicode /c= "2288" *)
Infix /c= 502 := nSubq.

Binder+ exists , := ex; and.

(* Parameter UPair "f55f90f052decfc17a366f12be0ad237becf63db26be5d163bf4594af99f943a" "e2a83319facad3a3d8ff453f4ef821d9da495e56a623695546bb7d7ac333f3fe" *)
Parameter UPair : set -> set -> set.

(* Parameter Sing "ee0b09fbfbda76156511ec03a1fc7c909693103f062263776c2c98a655837c92" "ec9394dc0cd84355682ca93f9e80c8aa367ef9c3479874f5f04da125c87db1f1" *)
Parameter Sing : set -> set.

(* Unicode Union "22C3" *)
Parameter Union : set->set.

Definition KPair : set -> set -> set := fun x y => UPair (UPair x y) (Sing x).

Definition equip : set -> set -> prop := fun X Y => exists Z, and (and (forall x, x :e X -> exists y, and (y :e Y) (KPair x y :e Z)) (forall y, y :e Y -> exists x, and (x :e X) (KPair x y :e Z))) (forall x y z u, KPair x y :e Z -> KPair z u :e Z -> iff (x = z) (y = u)).

Axiom the_ax : forall P:set->prop, forall x:set, P x -> P (the P).
Axiom setext : forall X Y:set, (forall x, iff (x :e X) (x :e Y)) -> X = Y.
Axiom UPair_ax : forall x y z, iff (x :e UPair y z) (or (x = y) (x = z)).
Axiom Union_ax : forall X x, iff (x :e Union X) (exists Y, and (x :e Y) (Y :e X)).
Axiom Regularity : forall X x, x :e X -> exists Y, and (Y :e X) (not (exists x, and (x :e X) (x :e Y))).
Axiom Replacement : forall A, forall P:set -> set -> prop, (forall x y z, P x y -> P x z -> y = z) -> exists X, forall x, iff (x :e X) (exists y, and (y :e A) (P y x)).
Axiom Tarski_A : forall N, exists M, and (and (and (N :e M) (forall X Y, X :e M -> Y c= X -> Y :e M)) (forall X, X :e M -> exists Z, and (Z :e M) (forall Y, Y c= X -> Y :e Z))) (forall X, X c= M -> or (equip X M) (X :e M)).

(* Unicode /\ "2227" *)
Infix /\ 780 left := and.
(* Unicode \/ "2228" *)
Infix \/ 785 left := or.
(* Unicode <-> "2194" *)
Infix <-> 805 := iff.

Axiom FalseE : False -> forall p:prop, p.
Axiom TrueI : True.
Axiom notI : forall A:prop, (A -> False) -> ~A.
Axiom notE : forall A:prop, ~A -> A -> False.
Axiom andI : forall (A B : prop), A -> B -> A /\ B.
Axiom andEL : forall (A B : prop), A /\ B -> A.
Axiom andER : forall (A B : prop), A /\ B -> B.
Axiom orIL : forall (A B : prop), A -> A \/ B.
Axiom orIR : forall (A B : prop), B -> A \/ B.
Axiom orE : forall (A B C:prop), (A -> C) -> (B -> C) -> A \/ B -> C.
Axiom iffEL : forall A B:prop, (A <-> B) -> A -> B.
Axiom iffER : forall A B:prop, (A <-> B) -> B -> A.
Axiom iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
Axiom iff_ref : forall A:prop, A <-> A.
Axiom the_ex : forall P:set -> prop, (exists x, P x) -> P (the P).
Axiom pred_ext : forall P Q:set -> prop, (forall x, P x <-> Q x) -> P = Q.
Axiom prop_ext_2 : forall p q:prop, (p -> q) -> (q -> p) -> p = q.
Axiom pred_ext_2 : forall P Q:set -> prop, P c= Q -> Q c= P -> P = Q.

Definition nIn : set->set->prop :=
fun x X => ~In x X.

(* Unicode /:e "2209" *)
Infix /:e 502 := nIn.

Notation SetEnum2 UPair.
Notation SetEnum1 Sing.

Axiom UPairE : forall x y z:set, x :e {y,z} -> x = y \/ x = z.
Axiom UPairI1 : forall y z:set, y :e {y,z}.
Axiom UPairI2 : forall y z:set, z :e {y,z}.
Axiom SingI : forall x:set, x :e {x}.
Axiom SingE : forall x y:set, y :e {x} -> y = x.
Axiom Sing_UPair_def : forall x, {x} = {x,x}.
Axiom Sing_inv : forall x Y, {x} = Y -> x :e Y /\ forall y :e Y, y = x.
Axiom Empty_ex : exists X, forall x, x /:e X.

Axiom KPair_pair_1 : forall x y z w, KPair x y = KPair z w -> x = z.
Axiom KPair_pair_2 : forall x y z w, KPair x y = KPair z w -> y = w.
Axiom KPair_pair : forall x y z w, KPair x y = KPair z w -> x = z /\ y = w.


(* Parameter Empty "7491fed394c0760ecce5d4e1df80fe76188bef2528794da082e0223de99066ce" "2ef0dbc560f4aba05346926782e584726ed94e6cc5f65568b80a37ddbfa5d716" *)
Parameter Empty : set.

Axiom EmptyE : forall x, x /:e Empty.
Axiom xm : forall P:prop, P \/ ~P.
Axiom UnionI : forall X x Y:set, x :e Y -> Y :e X -> x :e (Union X).
Axiom UnionE : forall X x:set, x :e (Union X) -> exists Y:set, x :e Y /\ Y :e X.
Axiom UnionE_impred : forall X x:set, x :e (Union X) -> forall p:prop, (forall Y:set, x :e Y -> Y :e X -> p) -> p.

Definition setlike : (set -> prop) -> prop := fun P => exists A, forall x, x :e A <-> P x.
(* Parameter toset "bdca5215bf0579642a4306b01a0f2340cb539f141f6dcbd4cd5121a880441e10" "35f96b90a9e6ba4d68debc67d325a43189a9073090012db0b4258b69dea9ca6f" *)
Parameter toset : (set -> prop) -> set.

Axiom setlike_toset : forall P:set -> prop, setlike P -> forall x, x :e toset P <-> P x.
Axiom toset_I : forall P:set -> prop, setlike P -> forall x, P x -> x :e toset P.
Axiom toset_E : forall P:set -> prop, setlike P -> forall x, x :e toset P -> P x.
Axiom setlike_set : forall A, setlike (fun x => x :e A).
Axiom toset_eq : forall A, toset (fun x => x :e A) = A.

(* Parameter Repl "fea72b9a680f666e24da732d2835c8d83e82d65c993a1597aca84bda2f745970" "3041a1cb0e073a46422f794fe16feb7d39d077e3958b5d236feecb2341d4ca6f" *)
Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.

(* Parameter Sep "8324d6b2a87d5e233d35100511422a76274b918c35d0c1ca109b0c52f6b24d83" "da98b582b06ed7e84a25bdac946c6310e931cc500e9c18c33b40a7d20304e6f9" *)
Parameter Sep : set -> (set -> prop) -> set.
Notation Sep Sep.

(* Parameter ReplSep "7f5ba2b987e7d7cf10ad34e82699aa594573af19f242f0e85c661d42702f3dfd" "bf4f61e2fabe0a1fcc27644aebe41c2c9f551c7841eb70b7ea8aea9ec77c0617" *)
Parameter ReplSep : set->(set->prop)->(set->set)->set.
Notation ReplSep ReplSep.

(* Parameter ReplSep2 "2ea0d769308e9d70b1f022110cce5a8144bba808781e62f7b5aa03428aa24c01" "868ecb350f4bcc784b08c7f7fccf538626ab64b0179356c34d81c8b667e01301" *)
Parameter ReplSep2 : set -> (set -> set) -> (set -> set -> prop) -> (set -> set -> set) -> set.

(* Parameter ReplSep3 "74c1c1a65001c3d95fa8106e185261aaaa20ee485febbb42517c5b2aa1027534" "f15a672df32291f747e546e2f03d8064ee4eaeb5dbb813a62b8e563574d872c7" *)
Parameter ReplSep3 : set -> (set -> set) -> (set -> set -> set) -> (set -> set -> set -> prop) -> (set -> set -> set -> set) -> set.

(* Parameter ReplSep4 "304e78affb4024981b5c312ecaa5db54d0f381d44cc6b4850ee9f61c765285a5" "58681465940c8432e4cd2ea30d9f024737b02f910547f8d65d1c37bd8236e3cd" *)
Parameter ReplSep4 : set -> (set -> set) -> (set -> set -> set) -> (set -> set -> set -> set) -> (set -> set -> set -> set -> prop) -> (set -> set -> set -> set -> set) -> set.

(* Parameter ReplSep5 "cc8cc72802470f9fe71a90032c89d059e8f649989d3c134d829630a4e4662ee0" "d8e4ad1680b2d5f214d433714f36ce2aa920867af726debdd9f176034ff75d68" *)
Parameter ReplSep5 : set -> (set -> set) -> (set -> set -> set) -> (set -> set -> set -> set) -> (set -> set -> set -> set -> set) -> (set -> set -> set -> set -> set -> prop) -> (set -> set -> set -> set -> set -> set) -> set.

(* Parameter ReplSep6 "c512d4fc02176acd7ab322b3a38225a539b03467e1d824203de55c70edb7a0de" "851df1105b4bf03d8629cc3796bcdfa07a97453c914ae15fad6a3a718f995bd4" *)
Parameter ReplSep6 : set -> (set -> set) -> (set -> set -> set) -> (set -> set -> set -> set) -> (set -> set -> set -> set -> set) -> (set -> set -> set -> set -> set -> set) -> (set -> set -> set -> set -> set -> set -> prop) -> (set -> set -> set -> set -> set -> set -> set) -> set.

(* Parameter ReplSep7 "b753854b84399d9aad5df80ada15b09f8bfe17a2ed354d778c78587c89402572" "bc6cf7ad5e60eae88ef7f8b08aedc2517064cef6ce3e6d54918cdc114af88bf1" *)
Parameter ReplSep7 : set -> (set -> set) -> (set -> set -> set) -> (set -> set -> set -> set) -> (set -> set -> set -> set -> set) -> (set -> set -> set -> set -> set -> set) -> (set -> set -> set -> set -> set -> set -> set) -> (set -> set -> set -> set -> set -> set -> set -> prop) -> (set -> set -> set -> set -> set -> set -> set -> set) -> set.

Axiom Repl_ex : forall A:set, forall F:set -> set, exists B:set, forall y, y :e B <-> exists x :e A, y = F x.
Axiom Repl_iff : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} <-> exists x :e A, y = F x.
Axiom ReplI : forall A:set, forall F:set->set, forall x:set, x :e A -> F x :e {F x|x :e A}.
Axiom ReplE : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> exists x :e A, y = F x.
Axiom ReplE_impred : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> forall p:prop, (forall x:set, x :e A -> y = F x -> p) -> p.
Axiom Sep_ex : forall A:set, forall P:set -> prop, exists B:set, forall x, x :e B <-> x :e A /\ P x.
Axiom Sep_iff : forall A, forall P:set -> prop, forall x, x :e {x :e A|P x} <-> x :e A /\ P x.
Axiom SepI:forall A:set, forall P:set->prop, forall x:set, x :e A -> P x -> x :e {x :e A|P x}.
Axiom SepE:forall A:set, forall P:set->prop, forall x:set, x :e {x :e A|P x} -> x :e A /\ P x.
Axiom SepE_impred:forall A:set, forall P:set->prop, forall x:set, x :e {x :e A|P x} -> forall q:prop, (x :e A -> P x -> q) -> q.
Axiom ReplSepI: forall A:set, forall P:set->prop, forall F:set->set, forall x:set, x :e A -> P x -> F x :e {F x|x :e A, P x}.
Axiom ReplSepE:forall A:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e A, P x} -> exists x :e A, P x /\ y = F x.
Axiom ReplSepE_impred:forall A:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e A, P x} -> forall p:prop, (forall x :e A, P x -> y = F x -> p) -> p.
Axiom ReplSep2I : forall A, forall B:set -> set, forall P:set -> set -> prop, forall F:set -> set -> set, forall x :e A, forall y :e B x, P x y -> F x y :e ReplSep2 A B P F.
Axiom ReplSep2E_impred : forall A, forall B:set -> set, forall P:set -> set -> prop, forall F:set -> set -> set, forall r :e ReplSep2 A B P F, forall p:prop, (forall x :e A, forall y :e B x, P x y -> r = F x y -> p) -> p.
Axiom ReplSep2E : forall A, forall B:set -> set, forall P:set -> set -> prop, forall F:set -> set -> set, forall r :e ReplSep2 A B P F, exists x :e A, exists y :e B x, P x y /\ r = F x y.
Axiom ReplSep3I : forall A, forall B:set -> set, forall C:set -> set -> set, forall P:set -> set -> set -> prop, forall F:set -> set -> set -> set, forall x :e A, forall y :e B x, forall z :e C x y, P x y z -> F x y z :e ReplSep3 A B C P F.
Axiom ReplSep3E_impred : forall A, forall B:set -> set, forall C:set -> set -> set, forall P:set -> set -> set -> prop, forall F:set -> set -> set -> set, forall r :e ReplSep3 A B C P F, forall p:prop, ( forall x :e A, forall y :e B x, forall z :e C x y, P x y z -> r = F x y z -> p) -> p.
Axiom ReplSep3E : forall A, forall B:set -> set, forall C:set -> set -> set, forall P:set -> set -> set -> prop, forall F:set -> set -> set -> set, forall r :e ReplSep3 A B C P F,  exists x :e A, exists y :e B x, exists z :e C x y, P x y z /\ r = F x y z.
Axiom ReplSep4I : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall P:set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set, forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, P x y z w -> F x y z w :e ReplSep4 A B C D P F.
Axiom ReplSep4E_impred : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall P:set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set, forall r :e ReplSep4 A B C D P F, forall p:prop, ( forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, P x y z w -> r = F x y z w -> p) -> p.
Axiom ReplSep4E : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall P:set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set, forall r :e ReplSep4 A B C D P F,  exists x :e A, exists y :e B x, exists z :e C x y, exists w :e D x y z, P x y z w /\ r = F x y z w.
Axiom ReplSep5I : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set, forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, forall u :e E x y z w, P x y z w u -> F x y z w u :e ReplSep5 A B C D E P F.
Axiom ReplSep5E_impred : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set, forall r :e ReplSep5 A B C D E P F, forall p:prop, ( forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, forall u :e E x y z w, P x y z w u -> r = F x y z w u -> p) -> p.
Axiom ReplSep5E : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set, forall r :e ReplSep5 A B C D E P F,  exists x :e A, exists y :e B x, exists z :e C x y, exists w :e D x y z, exists u :e E x y z w, P x y z w u /\ r = F x y z w u.
Axiom ReplSep6I : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall G:set -> set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set -> set, forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, forall u :e E x y z w, forall v :e G x y z w u, P x y z w u v -> F x y z w u v :e ReplSep6 A B C D E G P F.
Axiom ReplSep6E_impred : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall G:set -> set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set -> set, forall r :e ReplSep6 A B C D E G P F, forall p:prop, ( forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, forall u :e E x y z w, forall v :e G x y z w u, P x y z w u v -> r = F x y z w u v -> p) -> p.
Axiom ReplSep6E : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall G:set -> set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set -> set, forall r :e ReplSep6 A B C D E G P F,  exists x :e A, exists y :e B x, exists z :e C x y, exists w :e D x y z, exists u :e E x y z w, exists v :e G x y z w u, P x y z w u v /\ r = F x y z w u v.
Axiom ReplSep7I : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall G:set -> set -> set -> set -> set -> set, forall H:set -> set -> set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set -> set -> set, forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, forall u :e E x y z w, forall v :e G x y z w u, forall q :e H x y z w u v, P x y z w u v q -> F x y z w u v q :e ReplSep7 A B C D E G H P F.
Axiom ReplSep7E_impred : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall G:set -> set -> set -> set -> set -> set, forall H:set -> set -> set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set -> set -> set, forall r :e ReplSep7 A B C D E G H P F, forall p:prop, ( forall x :e A, forall y :e B x, forall z :e C x y, forall w :e D x y z, forall u :e E x y z w, forall v :e G x y z w u, forall q :e H x y z w u v, P x y z w u v q -> r = F x y z w u v q -> p) -> p.
Axiom ReplSep7E : forall A, forall B:set -> set, forall C:set -> set -> set, forall D:set -> set -> set -> set, forall E:set -> set -> set -> set -> set, forall G:set -> set -> set -> set -> set -> set, forall H:set -> set -> set -> set -> set -> set -> set, forall P:set -> set -> set -> set -> set -> set -> set -> prop, forall F:set -> set -> set -> set -> set -> set -> set -> set, forall r :e ReplSep7 A B C D E G H P F,  exists x :e A, exists y :e B x, exists z :e C x y, exists w :e D x y z, exists u :e E x y z w, exists v :e G x y z w u, exists q :e H x y z w u v, P x y z w u v q /\ r = F x y z w u v q.

Definition ocs : ((set -> set) -> prop) -> prop :=
  fun F : (set -> set) -> prop => forall x : (set -> set) -> set, exists X : set,
    forall f:set -> set, F f -> f X = x f.

(* Parameter mk_struct "427f0ef5742440a1124da6fe660e4e6f938faefd3128a4f2808ba54586c9b9b6" "8c205a89cfcb2e8b5423683a1b2598efe60a12d75498ef00caba70e6676d6be7" *)
Parameter mk_struct : ((set -> set) -> prop) -> ((set -> set) -> set) -> set.

(* Parameter strict_struct_p "fdd7cea73081c5804d71aa2eed69ef25c62c22a9cb24cdcba24c59f1a1ead504" "9f48546280520ee07a01fbf4fc17746d81c0c73dcd9f35fa97815d18f8bbe53a" *)
Parameter strict_struct_p : ((set -> set) -> prop) -> set -> prop.

Definition equ_struct : ((set -> set) -> prop) -> set -> set -> prop :=
  fun F:(set -> set) -> prop => fun X Y:set =>
   forall f:set -> set, F f -> f X = f Y.

Axiom sub_ocs : forall F G: (set -> set) -> prop, ocs G -> F c= G -> ocs F.
Axiom ocs_mk_struct_prop : forall F:(set -> set) -> prop, ocs F -> forall f:set -> set, F f -> forall x:(set -> set) -> set, f (mk_struct F x) = x f.
Axiom mk_struct_eta : forall F:(set -> set) -> prop, ocs F -> forall X:set, mk_struct F (fun f => f X) = mk_struct F (fun f => f (mk_struct F (fun f => f X))).
Axiom strict_mk_struct : forall F:(set -> set) -> prop, ocs F -> forall X:set, strict_struct_p F (mk_struct F (fun f => f X)).
Axiom equ_struct_ref : forall F:(set -> set) -> prop, forall X, equ_struct F X X.
Axiom equ_struct_sym : forall F:(set -> set) -> prop, forall X Y, equ_struct F X Y -> equ_struct F Y X.
Axiom equ_struct_tra : forall F:(set -> set) -> prop, forall X Y Z, equ_struct F X Y -> equ_struct F Y Z -> equ_struct F X Z.

Definition empty : set -> prop
 := fun X => forall x, x /:e X.

Axiom empty_nonempty : exists X, empty X.
Axiom empty_Empty : empty Empty.
Axiom empty_eq_Empty : forall X, empty X -> X = Empty.

Definition Element_of : set -> set -> prop
 := fun X x => x :e X \/ empty X /\ empty x.

Axiom Element_of_nonempty : forall X, exists x, Element_of X x.
Axiom Element_of_I1 : forall X, forall x :e X, Element_of X x.
Axiom Element_of_I2 : forall X, empty X -> Element_of X Empty.
Axiom Element_of_E1 : forall X, ~empty X -> forall x, Element_of X x -> x :e X.
Axiom Element_of_E2 : forall X, empty X -> forall x, Element_of X x -> x = Empty.
Axiom setlike_Element_of : forall X, setlike (Element_of X).
Axiom setof_Element_of : forall X, ~empty X -> toset (Element_of X) = X.

Section PropN.

Variable P1 P2 P3:prop.

Axiom and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
Axiom and3E : P1 /\ P2 /\ P3 -> (forall p:prop, (P1 -> P2 -> P3 -> p) -> p).
Axiom or3I1 : P1 -> P1 \/ P2 \/ P3.
Axiom or3I2 : P2 -> P1 \/ P2 \/ P3.
Axiom or3I3 : P3 -> P1 \/ P2 \/ P3.
Axiom or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).

Variable P4:prop.

Axiom and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
Axiom and4E : P1 /\ P2 /\ P3 /\ P4 -> (forall p:prop, (P1 -> P2 -> P3 -> P4 -> p) -> p).
Axiom or4I1 : P1 -> P1 \/ P2 \/ P3 \/ P4.
Axiom or4I2 : P2 -> P1 \/ P2 \/ P3 \/ P4.
Axiom or4I3 : P3 -> P1 \/ P2 \/ P3 \/ P4.
Axiom or4I4 : P4 -> P1 \/ P2 \/ P3 \/ P4.
Axiom or4E : P1 \/ P2 \/ P3 \/ P4 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> p).

Variable P5:prop.

Axiom and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
Axiom and5E : P1 /\ P2 /\ P3 /\ P4 /\ P5 -> (forall p:prop, (P1 -> P2 -> P3 -> P4 -> P5 -> p) -> p).
Axiom or5I1 : P1 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I2 : P2 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I3 : P3 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I4 : P4 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I5 : P5 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5E : P1 \/ P2 \/ P3 \/ P4 \/ P5 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> (P5 -> p) -> p).

Variable P6:prop.

Axiom and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
Axiom and6E : P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 -> (forall p:prop, (P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> p) -> p).

Variable P7:prop.

Axiom and7I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7.
Axiom and7E : P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7 -> (forall p:prop, (P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> p) -> p).

End PropN.

(** Two sets are equal if they have the same elements. Equivalently, we can always prove two sets are equal by proving they are subsets of each other. **)

Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom Subq_ref : forall X:set, X c= X.
Axiom Subq_tra : forall X Y Z:set, X c= Y -> Y c= Z -> X c= Z.
Axiom dneg : forall P:prop, ~~P -> P.
Axiom EmptyAx : ~exists x:set, x :e Empty.
Axiom Subq_Empty : forall X:set, Empty c= X.

(** UnionEq is Union_ax.
  Axiom UnionEq : forall X:set, forall x:set, x :e Union X <-> exists Y:set, x :e Y /\ Y :e X.
**)

(** (Power X) is the set of all subsets of X. **)

Axiom Power_ex : forall X, exists Z, forall Y, Y :e Z <-> Y c= X.

(* Parameter Power "bb1c4bb2e7b5e9ffd2978980d2b27d615cbc8bb8a123decb3fd54fb80dc2fcb9" "9018ff5b96ad378f36dab276f58bdc7d8fc18222c596ca3177be08a1acee9d2e" *)
(* Unicode Power "1D4AB" *)
Parameter Power : set->set.

Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.

Axiom PowerE : forall X Y:set, Y :e Power X -> Y c= X.

Axiom PowerI : forall X Y:set, Y c= X -> Y :e Power X.

Axiom Power_Subq : forall X Y:set, X c= Y -> Power X c= Power Y.

Axiom Empty_In_Power : forall X:set, Empty :e Power X.

Axiom Self_In_Power : forall X:set, X :e Power X.

(** Given a set X, (Union X) is the set {x | there is some Y such that x :e Y and Y :e X}. That is, Union gives the union of a set of sets. **)

(** Given a set X and a function F, (Repl F X) is the set {F x|x :e X}. That is, Repl allows us to form a set by
 replacing the elements x in a set X with corresponding elements F x. **)

(** ReplEq is Repl_iff.
Axiom ReplEq :
forall X:set, forall F:set->set, forall y:set, y :e {F x|x :e X} <-> exists x:set, x :e X /\ y = F x.
**)

(* Parameter binunion "859e7011bdff89bb687e84e00cdf046122d077684a4e029a72b72931a8ccf2fd" "3828378f54d092a4eb3a7645cd8c22019202c50241d1dbee65a720f73be8d9ed" *)
Parameter binunion : set -> set -> set.

(* Unicode :\/: "222a" *)
Infix :\/: 345 left := binunion.

Axiom binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
Axiom binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
Axiom binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.

Axiom SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
Axiom SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.

(* Parameter binintersect "90f614dd739d25d3ef425e964a31a540881f2cf48870dbbd385b87ffbffb0e90" "dd6eb054d2698e36085f2efc8acc57db2d0c170e482ca8d2a2c46b9a31a9d484" *)
Parameter binintersect:set->set->set.

(* Unicode :/\: "2229" *)
Infix :/\: 340 left := binintersect.

Axiom binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
Axiom binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
Axiom binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
Axiom binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.

(* Parameter ordsucc "905e14778dc45ba874b5f3f5f516dc7dcb7b42823b510bde2e8463b6dfba641f" "19043aec9cd19235befab2698aecb56ec899722f50cbe2d51d3738ba20ab5fc3" *)
Parameter ordsucc : set->set.

Axiom ordsuccI1 : forall x:set, x c= ordsucc x.
Axiom ordsuccI2 : forall x:set, x :e ordsucc x.
Axiom ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.

Notation Nat Empty ordsucc.

Axiom In_no2cycle : forall x y, x :e y -> y /:e x.

Axiom neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
Axiom neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
Axiom ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.
Axiom ordsucc_inj_contra : forall a b:set, a <> b -> ordsucc a <> ordsucc b.

Axiom In_0_1 : 0 :e 1.
Axiom In_1_2 : 1 :e 2.
Axiom In_0_2 : 0 :e 2.

Definition TransSet : set->prop := fun U:set => forall x :e U, x c= U.

Definition ordinal : set->prop := fun (alpha:set) => TransSet alpha /\ forall beta :e alpha, TransSet beta.

Axiom TransSet_In_ordsucc_Subq : forall x y, TransSet y -> x :e ordsucc y -> x c= y.
Axiom inv_Repl_eq : forall X, forall f g:set -> set, (forall x :e X, f (g x) = x) -> {f y|y :e {g x|x :e X}} = X.
Axiom invol_Repl_eq : forall X, forall f:set -> set, (forall x :e X, f (f x) = x) -> {f y|y :e {f x|x :e X}} = X.

Axiom ordinal_TransSet : forall alpha:set, ordinal alpha -> TransSet alpha.
Axiom ordinal_In_TransSet : forall alpha:set, ordinal alpha -> forall beta :e alpha, TransSet beta.
Axiom ordinal_Empty : ordinal Empty.
Axiom ordinal_Hered : forall alpha:set, ordinal alpha -> forall beta :e alpha, ordinal beta.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Axiom nat_0 : nat_p 0.
Axiom nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
Axiom nat_1 : nat_p 1.
Axiom nat_2 : nat_p 2.
Axiom nat_0_in_ordsucc : forall n, nat_p n -> 0 :e ordsucc n.
Axiom nat_ordsucc_in_ordsucc : forall n, nat_p n -> forall m :e n, ordsucc m :e ordsucc n.
Axiom nat_ind : forall p:set->prop, p 0 -> (forall n, nat_p n -> p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
Axiom nat_inv : forall n, nat_p n -> n = 0 \/ exists x, nat_p x /\ n = ordsucc x.
Axiom nat_complete_ind : forall p:set->prop, (forall n, nat_p n -> (forall m :e n, p m) -> p n) -> forall n, nat_p n -> p n.
Axiom nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
Axiom nat_trans : forall n, nat_p n -> forall m :e n, m c= n.
Axiom nat_ordsucc_trans : forall n, nat_p n -> forall m :e ordsucc n, m c= n.

Axiom TransSet_ordsucc : forall X:set, TransSet X -> TransSet (ordsucc X).

Axiom ordinal_ordsucc : forall alpha:set, ordinal alpha -> ordinal (ordsucc alpha).

Axiom nat_p_ordinal : forall n:set, nat_p n -> ordinal n.

Axiom omega_ex : exists omega, forall x, x :e omega <-> nat_p x.

(* Parameter omega "54f5b491560ccfc13fb2334a544117bd0f7903fe3f22751e4485e0b838a1016c" "80d24834aa9f66bdb9a5e1bbd38abd569c0980b113318e3a60b061de5affc484" *)
Parameter omega : set.

Axiom omega_iff : forall x, x :e omega <-> nat_p x.

Axiom omega_nat_p : forall n :e omega, nat_p n.

Axiom nat_p_omega : forall n:set, nat_p n -> n :e omega.

Axiom omega_0 : 0 :e omega.

Axiom omega_ordsucc : forall n :e omega, ordsucc n :e omega.

Definition Union_nat_reln : set -> set -> set -> prop :=
 fun n X Y =>
    forall p:set -> set -> prop,
        p 0 X
     -> (forall n, nat_p n -> forall Z, p n Z -> p (ordsucc n) (Union Z))
     -> p n Y.

Axiom Union_nat_reln_0 : forall X, Union_nat_reln 0 X X.

Axiom Union_nat_reln_S : forall X n, nat_p n -> forall Z, Union_nat_reln n X Z -> Union_nat_reln (ordsucc n) X (Union Z).

Axiom Union_nat_reln_ind : forall X, forall p:set -> set -> prop,
    p 0 X
 -> (forall n, nat_p n -> forall Z, Union_nat_reln n X Z -> p n Z -> p (ordsucc n) (Union Z))
 -> forall n Y, nat_p n -> Union_nat_reln n X Y -> p n Y.

Axiom Union_nat_reln_inv : forall X n Y, nat_p n -> Union_nat_reln n X Y -> n = 0 /\ Y = X \/ exists m Z, n = ordsucc m /\ Y = Union Z /\ Union_nat_reln m X Z.

Axiom Union_nat_reln_0_inv : forall X Y, Union_nat_reln 0 X Y -> Y = X.

Axiom Union_nat_reln_S_inv : forall n X Y, nat_p n -> Union_nat_reln (ordsucc n) X Y -> exists Z, Y = Union Z /\ Union_nat_reln n X Z.

Axiom Union_nat_reln_ex : forall X, forall n, nat_p n -> exists Y, Union_nat_reln n X Y.

Axiom Union_nat_reln_uniq : forall X, forall n, nat_p n -> forall Y Z, Union_nat_reln n X Y -> Union_nat_reln n X Z -> Y = Z.

Axiom the_Union_nat_prop : forall n X, nat_p n -> Union_nat_reln n X (the (Union_nat_reln n X)).

Axiom the_Union_nat_0_eq : forall X, the (Union_nat_reln 0 X) = X.

Axiom the_Union_nat_S_eq : forall n X, nat_p n -> the (Union_nat_reln (ordsucc n) X) = Union (the (Union_nat_reln n X)).

(* Parameter TransSet_clos "502f21ab0254e47362b0daca5e5c363f6666d6df40de65626e202f564a8b6b8d" "d42eff8eec7ad63514db51c7eb51eff47b0b92320b5fbd167da2e6db7d5a8e53" *)
Parameter TransSet_clos : set -> set.

Axiom TransSet_clos_I : forall X z n, nat_p n -> z :e the (Union_nat_reln n X) -> z :e TransSet_clos X.

Axiom TransSet_clos_E : forall X z, z :e TransSet_clos X -> forall p:prop, (forall n, nat_p n -> z :e the (Union_nat_reln n X) -> p) -> p.

Axiom TransSet_clos_subq : forall X, X c= TransSet_clos X.

Axiom TransSet_clos_trans : forall X, TransSet (TransSet_clos X).

(** Sets are formed iteratively, so we can prove properties about all sets by induction on membership.
Suppose P is a property of sets. If we can prove P holds for X from the inductive hypothesis that P holds for all member of X,
then P must hold for all sets. **)

Axiom In_ind : forall P:set->prop, (forall X:set, (forall x :e X, P x) -> P X) -> forall X:set, P X.

Definition bij : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Axiom bij_equip : forall X Y, forall f:set -> set, bij X Y f -> equip X Y.
Axiom equip_bij : forall X Y, equip X Y -> exists f:set -> set, bij X Y f.

(* Parameter inv "e1e47685e70397861382a17f4ecc47d07cdab63beca11b1d0c6d2985d3e2d38b" "896fa967e973688effc566a01c68f328848acd8b37e857ad23e133fdd4a50463" *)
Parameter inv : set -> (set -> set) -> set -> set.

Axiom surj_rinv : forall X Y, forall f:set->set, (forall w :e Y, exists u :e X, f u = w) -> forall y :e Y, inv X f y :e X /\ f (inv X f y) = y.
Axiom inj_linv : forall X Y, forall f:set->set, (forall u v :e X, f u = f v -> u = v) -> forall x :e X, inv X f (f x) = x.

Axiom bij_inv : forall X Y, forall f:set->set, bij X Y f -> bij Y X (inv X f).
Axiom bij_comp : forall X Y Z:set, forall f g:set->set, bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
Axiom bij_id : forall X, bij X X (fun x => x).

Axiom In_irref : forall x, x /:e x.
Axiom In_no3cycle : forall x y z, x :e y -> y :e z -> z /:e x.

Axiom the_set_R : forall X:set, forall P:set->prop, forall x :e X, P x -> the (fun x => x :e X /\ P x) :e X /\ P (the (fun x => x :e X /\ P x)).

(* Parameter If_i "8c8f550868df4fdc93407b979afa60092db4b1bb96087bc3c2f17fadf3f35cbf" "b8ff52f838d0ff97beb955ee0b26fad79602e1529f8a2854bda0ecd4193a8a3c" *)
Parameter If_i : prop->set->set->set.

Notation IfThenElse If_i.

Axiom If_i_correct : forall p:prop, forall x y:set,
p /\ (if p then x else y) = x \/ ~p /\ (if p then x else y) = y.

Axiom If_i_0 : forall p:prop, forall x y:set,
~ p -> (if p then x else y) = y.

Axiom If_i_1 : forall p:prop, forall x y:set,
p -> (if p then x else y) = x.

Axiom If_i_or : forall p:prop, forall x y:set, (if p then x else y) = x \/ (if p then x else y) = y.

Axiom If_i_eta : forall p:prop, forall x:set, (if p then x else x) = x.

Axiom exandE_i : forall P Q:set -> prop, (exists x, P x /\ Q x) -> forall r:prop, (forall x, P x -> Q x -> r) -> r.

Axiom exandE_ii : forall P Q:(set -> set) -> prop, (exists x:set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set, P x -> Q x -> p) -> p.

Axiom exandE_iii : forall P Q:(set -> set -> set) -> prop, (exists x:set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set, P x -> Q x -> p) -> p.

Axiom exandE_iiii : forall P Q:(set -> set -> set -> set) -> prop, (exists x:set -> set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set -> set, P x -> Q x -> p) -> p.

Axiom exandE_iio : forall P Q:(set -> set -> prop) -> prop, (exists x:set -> set -> prop, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> prop, P x -> Q x -> p) -> p.

Axiom exandE_iiio : forall P Q:(set -> set -> set -> prop) -> prop, (exists x:set -> set -> set -> prop, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set -> prop, P x -> Q x -> p) -> p.

Section Descr_ii.

Variable P : (set -> set) -> prop.

(* Parameter Descr_ii "a6e81668bfd1db6e6eb6a13bf66094509af176d9d0daccda274aa6582f6dcd7c" "3bae39e9880bbf5d70538d82bbb05caf44c2c11484d80d06dee0589d6f75178c" *)
Parameter Descr_ii : set -> set.

Hypothesis Pex: exists f:set -> set, P f.
Hypothesis Puniq: forall f g:set -> set, P f -> P g -> f = g.

Axiom Descr_ii_prop : P Descr_ii.

End Descr_ii.

Section Descr_iii.

Variable P : (set -> set -> set) -> prop.

(* Parameter Descr_iii "dc42f3fe5d0c55512ef81fe5d2ad0ff27c1052a6814b1b27f5a5dcb6d86240bf" "ca5fc17a582fdd4350456951ccbb37275637ba6c06694213083ed9434fe3d545" *)
Parameter Descr_iii : set -> set -> set.

Hypothesis Pex: exists f:set -> set -> set, P f.
Hypothesis Puniq: forall f g:set -> set -> set, P f -> P g -> f = g.

Axiom Descr_iii_prop : P Descr_iii.

End Descr_iii.

Section Descr_iio.

Variable P : (set -> set -> prop) -> prop.

(* Parameter Descr_iio "9909a953d666fea995cf1ccfe3d98dba3b95210581af4af82ae04f546c4c34a5" "e8e5113bb5208434f24bf352985586094222b59a435d2d632e542c768fb9c029" *)
Parameter Descr_iio : set -> set -> prop.

Hypothesis Pex: exists f:set -> set -> prop, P f.
Hypothesis Puniq: forall f g:set -> set -> prop, P f -> P g -> f = g.

Axiom Descr_iio_prop : P Descr_iio.

End Descr_iio.

Section Descr_Vo1.

Variable P : Vo 1 -> prop.

(* Parameter Descr_Vo1 "322bf09a1711d51a4512e112e1767cb2616a7708dc89d7312c8064cfee6e3315" "615c0ac7fca2b62596ed34285f29a77b39225d1deed75d43b7ae87c33ba37083" *)
Parameter Descr_Vo1 : Vo 1.

Hypothesis Pex: exists f:Vo 1, P f.
Hypothesis Puniq: forall f g:Vo 1, P f -> P g -> f = g.

Axiom Descr_Vo1_prop : P Descr_Vo1.

End Descr_Vo1.

Section Descr_Vo2.

Variable P : Vo 2 -> prop.

(* Parameter Descr_Vo2 "cc8f114cf9f75d4b7c382c62411d262d2241962151177e3b0506480d69962acc" "a64b5b4306387d52672cb5cdbc1cb423709703e6c04fdd94fa6ffca008f7e1ab" *)
Parameter Descr_Vo2 : Vo 2.

Hypothesis Pex: exists f:Vo 2, P f.
Hypothesis Puniq: forall f g:Vo 2, P f -> P g -> f = g.

Axiom Descr_Vo2_prop : P Descr_Vo2.

End Descr_Vo2.

Section If_ii.

Variable p:prop.
Variable f g:set -> set.

(* Parameter If_ii "e76df3235104afd8b513a92c00d3cc56d71dd961510bf955a508d9c2713c3f29" "17057f3db7be61b4e6bd237e7b37125096af29c45cb784bb9cc29b1d52333779" *)
Parameter If_ii : set -> set.

Axiom If_ii_1 : p -> If_ii = f.

Axiom If_ii_0 : ~p -> If_ii = g.

End If_ii.

Section If_iii.

Variable p:prop.
Variable f g:set -> set -> set.

(* Parameter If_iii "53034f33cbed012c3c6db42812d3964f65a258627a765f5bede719198af1d1ca" "3314762dce5a2e94b7e9e468173b047dd4a9fac6ee2c5f553c6ea15e9c8b7542" *)
Parameter If_iii : set -> set -> set.

Axiom If_iii_1 : p -> If_iii = f.

Axiom If_iii_0 : ~p -> If_iii = g.

End If_iii.

Section If_Vo1.

Variable p:prop.
Variable f g:Vo 1.

(* Parameter If_Vo1 "33be70138f61ae5ce327b6b29a949448c54f06c2da932a4fcf7d7a0cfc29f72e" "2bb1d80de996e76ceb61fc1636c53ea4dc6f7ce534bd5caee16a3ba4c8794a58" *)
Parameter If_Vo1 : Vo 1.

Axiom If_Vo1_1 : p -> If_Vo1 = f.

Axiom If_Vo1_0 : ~p -> If_Vo1 = g.

End If_Vo1.

Section If_iio.

Variable p:prop.
Variable f g:set -> set -> prop.

(* Parameter If_iio "216c935441f8678edc47540d419667fe9e5ab01fda1f1afbc64eacaea6a9cbfc" "bf2fb7b3431387bbd1ede0aa0b590233207130df523e71e36aaebd675479e880" *)
Parameter If_iio : set -> set -> prop.

Axiom If_iio_1 : p -> If_iio = f.

Axiom If_iio_0 : ~p -> If_iio = g.

End If_iio.

Section If_Vo2.

Variable p:prop.
Variable f g:Vo 2.

(* Parameter If_Vo2 "8117f6db2fb9c820e5905451e109f8ef633101b911baa48945806dc5bf927693" "6cf28b2480e4fa77008de59ed21788efe58b7d6926c3a8b72ec889b0c27b2f2e" *)
Parameter If_Vo2 : Vo 2.

Axiom If_Vo2_1 : p -> If_Vo2 = f.

Axiom If_Vo2_0 : ~p -> If_Vo2 = g.

End If_Vo2.

Section EpsilonRec_i.

Variable F:set -> (set -> set) -> set.

(* Parameter In_rec_i "f97da687c51f5a332ff57562bd465232bc70c9165b0afe0a54e6440fc4962a9f" "fac413e747a57408ad38b3855d3cde8673f86206e95ccdadff2b5babaf0c219e" *)
Parameter In_rec_i : set -> set.

Hypothesis Fr:forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_i_eq : forall X:set, In_rec_i X = F X In_rec_i.

End EpsilonRec_i.

Section EpsilonRec_ii.

Variable F:set -> (set -> (set -> set)) -> (set -> set).

(* Parameter In_rec_ii "4d137cad40b107eb0fc2c707372525f1279575e6cadb4ebc129108161af3cedb" "f3c9abbc5074c0d68e744893a170de526469426a5e95400ae7fc81f74f412f7e" *)
Parameter In_rec_ii : set -> (set -> set).

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_ii_eq : forall X:set, In_rec_ii X = F X In_rec_ii.

End EpsilonRec_ii.

Section EpsilonRec_iii.

Variable F:set -> (set -> (set -> set -> set)) -> (set -> set -> set).

(* Parameter In_rec_iii "222f1b8dcfb0d2e33cc4b232e87cbcdfe5c4a2bdc5326011eb70c6c9aeefa556" "9b3a85b85e8269209d0ca8bf18ef658e56f967161bf5b7da5e193d24d345dd06" *)
Parameter In_rec_iii : set -> (set -> set -> set).

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_iii_eq : forall X:set, In_rec_iii X = F X In_rec_iii.

End EpsilonRec_iii.

Section EpsilonRec_iio.

Variable F:set -> (set -> (set -> set -> prop)) -> (set -> set -> prop).

(* Parameter In_rec_iio "2cb990eb7cf33a7bea142678f254baf1970aa17b7016039b89df7652eff72aba" "8465061e06db87ff5ec9bf4bd2245a29d557f6b265478036bee39419282a5e28" *)
Parameter In_rec_iio : set -> (set -> set -> prop).

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set -> prop), (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_iio_eq : forall X:set, In_rec_iio X = F X In_rec_iio.

End EpsilonRec_iio.

Section EpsilonRec_Vo1.

Variable F:set -> (set -> Vo 1) -> Vo 1.

(* Parameter In_rec_Vo1 "45519cf90ff63f7cea32c7ebbbae0922cfc609d577dc157e25e68e131cddf2df" "e9c5f22f769cd18d0d29090a943f66f6006f0d132fafe90f542ee2ee8a3f7b59" *)
Parameter In_rec_Vo1 : set -> Vo 1.

Hypothesis Fr:forall X:set, forall g h:set -> Vo 1, (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_Vo1_eq : forall X:set, In_rec_Vo1 X = F X In_rec_Vo1.

End EpsilonRec_Vo1.

Section EpsilonRec_Vo2.

Variable F:set -> (set -> Vo 2) -> Vo 2.

(* Parameter In_rec_Vo2 "e249fde27e212bc28b301523be2eee37636e29fc084bd9b775cb02f921e2ad7f" "8bc8d37461c7653ced731399d140c0d164fb9231e77b2824088e534889c31596" *)
Parameter In_rec_Vo2 : set -> Vo 2.

Hypothesis Fr:forall X:set, forall g h:set -> Vo 2, (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_Vo2_eq : forall X:set, In_rec_Vo2 X = F X In_rec_Vo2.

End EpsilonRec_Vo2.

Section If_Vo3.

Variable p:prop.
Variable f g:Vo 3.

(* Parameter If_Vo3 "5b91106169bd98c177a0ff2754005f1488a83383fc6fc918d8c61f613843cf0f" "73dd2d0fb9a3283dfd7b1d719404da0bf605e7b4c7b714a2b4e2cb1a38d98c6f" *)
Parameter If_Vo3 : Vo 3.

Axiom If_Vo3_1 : p -> If_Vo3 = f.

Axiom If_Vo3_0 : ~p -> If_Vo3 = g.

End If_Vo3.

Section Descr_Vo3.

Variable P : Vo 3 -> prop.

(* Parameter Descr_Vo3 "2e63292920e9c098907a70c431c7555afc9d4d26c8920d41192c83c02196acbe" "f25ee4a03f8810e3e5a11b184db6c8f282acaa7ef4bfd93c4b2de131431b977c" *)
Parameter Descr_Vo3 : Vo 3.

Hypothesis Pex: exists f:Vo 3, P f.
Hypothesis Puniq: forall f g:Vo 3, P f -> P g -> f = g.

Axiom Descr_Vo3_prop : P Descr_Vo3.

End Descr_Vo3.

Section EpsilonRec_Vo3.

Variable F:set -> (set -> Vo 3) -> Vo 3.

(* Parameter In_rec_Vo3 "058168fdbe0aa41756ceb986449745cd561e65bf2dd594384cd039169aa7ec90" "80f7da89cc801b8279f42f9e1ed519f72d50d76e88aba5efdb67c4ae1e59aee0" *)
Parameter In_rec_Vo3 : set -> Vo 3.

Hypothesis Fr:forall X:set, forall g h:set -> Vo 3, (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_Vo3_eq : forall X:set, In_rec_Vo3 X = F X In_rec_Vo3.

End EpsilonRec_Vo3.

Section If_Vo4.

Variable p:prop.
Variable f g:Vo 4.

(* Parameter If_Vo4 "6dc2e406a4ee93aabecb0252fd45bdf4b390d29b477ecdf9f4656d42c47ed098" "1a8f92ceed76bef818d85515ce73c347dd0e2c0bcfd3fdfc1fcaf4ec26faed04" *)
Parameter If_Vo4 : Vo 4.

Axiom If_Vo4_1 : p -> If_Vo4 = f.
Axiom If_Vo4_0 : ~p -> If_Vo4 = g.

End If_Vo4.

Section Descr_Vo4.

Variable P : Vo 4 -> prop.

(* Parameter Descr_Vo4 "28ea4ee0409fe1fc4b4516175b2254cb311b9609fd2a4015768b4a520fe69214" "8b81abb8b64cec9ea874d5c4dd619a9733a734933a713ef54ed7e7273510b0c3" *)
Parameter Descr_Vo4 : Vo 4.

Hypothesis Pex: exists f:Vo 4, P f.
Hypothesis Puniq: forall f g:Vo 4, P f -> P g -> f = g.

Axiom Descr_Vo4_prop : P Descr_Vo4.

End Descr_Vo4.

Section EpsilonRec_Vo4.

Variable F:set -> (set -> Vo 4) -> Vo 4.

(* Parameter In_rec_Vo4 "65bb4bac5d306fd1707029e38ff3088a6d8ed5aab414f1faf79ba5294ee2d01e" "d82c5791815ca8155da516354e8f8024d8b9d43a14ce62e2526e4563ff64e67f" *)
Parameter In_rec_Vo4 : set -> Vo 4.

Hypothesis Fr:forall X:set, forall g h:set -> Vo 4, (forall x :e X, g x = h x) -> F X g = F X h.

Axiom In_rec_Vo4_eq : forall X:set, In_rec_Vo4 X = F X In_rec_Vo4.

End EpsilonRec_Vo4.

(* Parameter exactly1of2 "3578b0d6a7b318714bc5ea889c6a38cf27f08eaccfab7edbde3cb7a350cf2d9b" "163602f90de012a7426ee39176523ca58bc964ccde619b652cb448bd678f7e21" *)
Parameter exactly1of2 : prop->prop->prop.

Axiom exactly1of2_I1 : forall A B:prop, A -> ~B -> exactly1of2 A B.
Axiom exactly1of2_I2 : forall A B:prop, ~A -> B -> exactly1of2 A B.
Axiom exactly1of2_impI1 : forall A B:prop, (A -> ~B) -> (~A -> B) -> exactly1of2 A B.
Axiom exactly1of2_impI2 : forall A B:prop, (B -> ~A) -> (~B -> A) -> exactly1of2 A B.

Axiom exactly1of2_E : forall A B:prop, exactly1of2 A B ->
forall p:prop,
(A -> ~B -> p) ->
(~A -> B -> p) ->
p.

Axiom exactly1of2_or : forall A B:prop, exactly1of2 A B -> A \/ B.

Axiom exactly1of2_impn12 : forall A B:prop, exactly1of2 A B -> A -> ~B.

Axiom exactly1of2_impn21 : forall A B:prop, exactly1of2 A B -> B -> ~A.

Axiom exactly1of2_nimp12 : forall A B:prop, exactly1of2 A B -> ~A -> B.

Axiom exactly1of2_nimp21 : forall A B:prop, exactly1of2 A B -> ~B -> A.

(* Parameter exactly1of3 "d2a0e4530f6e4a8ef3d5fadfbb12229fa580c2add302f925c85ede027bb4b175" "aa4bcd059b9a4c99635877362627f7d5998ee755c58679934cc62913f8ef06e0" *)
Parameter exactly1of3 : prop->prop->prop->prop.

Axiom exactly1of3_I1 : forall A B C:prop, A -> ~B -> ~C -> exactly1of3 A B C.
Axiom exactly1of3_I2 : forall A B C:prop, ~A -> B -> ~C -> exactly1of3 A B C.
Axiom exactly1of3_I3 : forall A B C:prop, ~A -> ~B -> C -> exactly1of3 A B C.

Axiom exactly1of3_impI1 : forall A B C:prop, (A -> ~B) -> (A -> ~C) -> (B -> ~C) -> (~A -> B \/ C) -> exactly1of3 A B C.
Axiom exactly1of3_impI2 : forall A B C:prop, (B -> ~A) -> (B -> ~C) -> (A -> ~C) -> (~B -> A \/ C) -> exactly1of3 A B C.
Axiom exactly1of3_impI3 : forall A B C:prop, (C -> ~A) -> (C -> ~B) -> (A -> ~B) -> (~A -> B) -> exactly1of3 A B C.

Axiom exactly1of3_E : forall A B C:prop, exactly1of3 A B C ->
forall p:prop,
(A -> ~B -> ~C -> p) ->
(~A -> B -> ~C -> p) ->
(~A -> ~B -> C -> p) ->
p.

Axiom exactly1of3_or : forall A B C:prop, exactly1of3 A B C -> A \/ B \/ C.

Axiom exactly1of3_impn12 : forall A B C:prop, exactly1of3 A B C -> A -> ~B.
Axiom exactly1of3_impn13 : forall A B C:prop, exactly1of3 A B C -> A -> ~C.
Axiom exactly1of3_impn21 : forall A B C:prop, exactly1of3 A B C -> B -> ~A.
Axiom exactly1of3_impn23 : forall A B C:prop, exactly1of3 A B C -> B -> ~C.
Axiom exactly1of3_impn31 : forall A B C:prop, exactly1of3 A B C -> C -> ~A.
Axiom exactly1of3_impn32 : forall A B C:prop, exactly1of3 A B C -> C -> ~B.
Axiom exactly1of3_nimp1 : forall A B C:prop, exactly1of3 A B C -> ~A -> B \/ C.
Axiom exactly1of3_nimp2 : forall A B C:prop, exactly1of3 A B C -> ~B -> A \/ C.
Axiom exactly1of3_nimp3 : forall A B C:prop, exactly1of3 A B C -> ~C -> A \/ B.

Definition bigintersect := fun (D:(set->prop)->prop) (x:set) => forall P:set->prop, D P -> P x.

Definition reflexive : (set->set->prop)->prop := fun R => forall x:set, R x x.
Definition irreflexive : (set->set->prop)->prop := fun R => forall x:set, ~R x x.
Definition symmetric : (set->set->prop)->prop := fun R => forall x y:set, R x y -> R y x.
Definition antisymmetric : (set->set->prop)->prop := fun R => forall x y:set, R x y -> R y x -> x = y.
Definition transitive : (set->set->prop)->prop := fun R => forall x y z:set, R x y -> R y z -> R x z.
Definition eqreln : (set->set->prop)->prop := fun R => reflexive R /\ symmetric R /\ transitive R.
Definition per : (set->set->prop)->prop := fun R => symmetric R /\ transitive R.
Definition linear : (set->set->prop)->prop := fun R => forall x y:set, R x y \/ R y x.
Definition trichotomous_or : (set->set->prop)->prop := fun R => forall x y:set, R x y \/ x = y \/ R y x.
Definition partialorder : (set->set->prop)->prop := fun R => reflexive R /\ antisymmetric R /\ transitive R.
Definition totalorder : (set->set->prop)->prop := fun R => partialorder R /\ linear R.
Definition strictpartialorder : (set->set->prop)->prop := fun R => irreflexive R /\ transitive R.
Definition stricttotalorder : (set->set->prop)->prop := fun R => strictpartialorder R /\ trichotomous_or R.

Axiom per_sym : forall R:set->set->prop, per R -> symmetric R.

Axiom per_tra : forall R:set->set->prop, per R -> transitive R.

Axiom per_stra1 : forall R:set->set->prop, per R -> forall x y z:set, R y x -> R y z -> R x z.

Axiom per_stra2 : forall R:set->set->prop, per R -> forall x y z:set, R x y -> R z y -> R x z.

Axiom per_stra3 : forall R:set->set->prop, per R -> forall x y z:set, R y x -> R z y -> R x z.

Axiom per_ref1 : forall R:set->set->prop, per R -> forall x y:set, R x y -> R x x.

Axiom per_ref2 : forall R:set->set->prop, per R -> forall x y:set, R x y -> R y y.

Axiom partialorder_strictpartialorder : forall R:set->set->prop,
  partialorder R -> strictpartialorder (fun x y => R x y /\ x <> y).

Definition reflclos : (set->set->prop)->(set->set->prop) := fun R x y => R x y \/ x = y.

Axiom reflclos_refl : forall R:set->set->prop, reflexive (reflclos R).

Axiom reflclos_min : forall R S:set->set->prop, R c= S -> reflexive S -> reflclos R c= S.

Axiom strictpartialorder_partialorder_reflclos : forall R:set->set->prop, strictpartialorder R -> partialorder (reflclos R).

Axiom stricttotalorder_totalorder_reflclos : forall R:set->set->prop,
  stricttotalorder R -> totalorder (reflclos R).

Section Zermelo1908.

(* Parameter ZermeloWO "dc4124cb3e699eb9154ce37eaa547c4d08adc8fd41c311d706024418f4f1c8d6" "36a362f5d7e56550e98a38468fb4fc4d70ea17f4707cfdd2f69fc2cce37a9643" *)
Parameter ZermeloWO : set -> set -> prop.

Axiom ZermeloWO_Eps : forall a:set, (the (ZermeloWO a)) = a.
Axiom ZermeloWO_ref : reflexive ZermeloWO.
Axiom ZermeloWO_lin : linear ZermeloWO.
Axiom ZermeloWO_tra : transitive ZermeloWO.
Axiom ZermeloWO_antisym : antisymmetric ZermeloWO.
Axiom ZermeloWO_partialorder : partialorder ZermeloWO.
Axiom ZermeloWO_totalorder : totalorder ZermeloWO.
Axiom ZermeloWO_wo : forall p:set->prop, (exists x:set, p x) -> exists x:set, p x /\ forall y:set, p y -> ZermeloWO x y.

Definition ZermeloWOstrict := fun (a b:set) => ZermeloWO a b /\ a <> b.

Axiom ZermeloWOstrict_trich : trichotomous_or ZermeloWOstrict.
Axiom ZermeloWOstrict_stricttotalorder : stricttotalorder ZermeloWOstrict.
Axiom ZermeloWOstrict_wo : forall (p:set -> prop), (exists x:set, p x) -> exists x:set, p x /\ forall y:set, p y /\ y <> x -> ZermeloWOstrict x y.

Axiom Zermelo_WO : exists r : set -> set -> prop,
    totalorder r
 /\ (forall p:set->prop, (exists x:set, p x) -> exists x:set, p x /\ forall y:set, p y -> r x y).

Axiom Zermelo_WO_strict : exists r : set -> set -> prop,
    stricttotalorder r
 /\ (forall p:set->prop, (exists x:set, p x) -> exists x:set, p x /\ forall y:set, p y /\ y <> x -> r x y).

End Zermelo1908.

Axiom not_and_or_demorgan : forall A B:prop, ~(A /\ B) -> ~A \/ ~B.
Axiom eq_imp_or : (fun (x y:prop) => (x -> y)) = (fun (x y:prop) => (~x \/ y)).
Axiom Subq_contra : forall X Y z:set, X c= Y -> z /:e Y -> z /:e X.
Axiom Empty_Subq_eq : forall X:set, X c= Empty -> X = Empty.
Axiom Empty_eq : forall X:set, (forall x, x /:e X) -> X = Empty.
Axiom Union_Empty : Union Empty = Empty.
Axiom Union_Power_Subq : forall X:set, Union (Power X) c= X.
Axiom Repl_Empty : forall F:set -> set, {F x|x :e Empty} = Empty.
Axiom ReplEq_ext : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} = {G x|x :e X}.
Axiom UPair_com : forall x y:set, {x,y} = {y,x}.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.

Axiom Power_0_Sing_0 : Power Empty = {Empty}.
Axiom Repl_UPair : forall F:set->set, forall x y:set, {F z|z :e {x,y}} = {F x,F y}.
Axiom Repl_Sing : forall F:set->set, forall x:set, {F z|z :e {x}} = {F x}.

(* Parameter famunion "b37c45ca1b39ef7beb231562b95d8f2008d19d737d0aa5c61951d33806a71055" "333b249faa15a516bac392a709735971aac1959219180f6500350954b28acf90" *)
Parameter famunion:set->(set->set)->set.

(* Unicode \/_ "22C3" *)
(* Subscript \/_ *)
Binder \/_ , := famunion.

Axiom famunionI:forall X:set, forall F:(set->set), forall x y:set, x :e X -> y :e F x -> y :e \/_ x :e X, F x.
Axiom famunionE:forall X:set, forall F:(set->set), forall y:set, y :e (\/_ x :e X, F x) -> exists x :e X, y :e F x.
Axiom famunionE_impred : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> forall p:prop, (forall x, x :e X -> y :e F x -> p) -> p.

Axiom UnionEq_famunionId:forall X:set, Union X = \/_ x :e X, x.
Axiom ReplEq_famunion_Sing:forall X:set, forall F:(set->set), {F x|x :e X} = \/_ x :e X, {F x}.
Axiom Empty_or_ex : forall X:set, X = Empty \/ exists x:set, x :e X.
Axiom Power_Sing : forall x:set, Power {x} = {Empty,{x}}.
Axiom Power_Sing_0 : Power {Empty} = {Empty,{Empty}}.
Axiom Sep_Subq : forall X:set, forall P:set->prop, {x :e X|P x} c= X.
Axiom Sep_In_Power : forall X:set, forall P:set->prop, {x :e X|P x} :e Power X.

Axiom binunion_asso:forall X Y Z:set, X :\/: (Y :\/: Z) = (X :\/: Y) :\/: Z.
Axiom binunion_com_Subq:forall X Y:set, X :\/: Y c= Y :\/: X.
Axiom binunion_com:forall X Y:set, X :\/: Y = Y :\/: X.
Axiom binunion_idl:forall X:set, Empty :\/: X = X.
Axiom binunion_idr:forall X:set, X :\/: Empty = X.
Axiom binunion_idem:forall X:set, X :\/: X = X.
Axiom binunion_Subq_1: forall X Y:set, X c= X :\/: Y.
Axiom binunion_Subq_2: forall X Y:set, Y c= X :\/: Y.
Axiom binunion_Subq_min: forall X Y Z:set, X c= Z -> Y c= Z -> X :\/: Y c= Z.
Axiom Subq_binunion_eq:forall X Y, (X c= Y) = (X :\/: Y = Y).
Axiom binunion_nIn_I : forall X Y z:set, z /:e X -> z /:e Y -> z /:e X :\/: Y.
Axiom binunion_nIn_E : forall X Y z:set, z /:e X :\/: Y -> z /:e X /\ z /:e Y.
Axiom binintersect_Subq_1:forall X Y:set, X :/\: Y c= X.
Axiom binintersect_Subq_2:forall X Y:set, X :/\: Y c= Y.
Axiom binintersect_Subq_eq_1 : forall X Y, X c= Y -> X :/\: Y = X.
Axiom binintersect_Subq_max:forall X Y Z:set, Z c= X -> Z c= Y -> Z c= X :/\: Y.
Axiom binintersect_asso:forall X Y Z:set, X :/\: (Y :/\: Z) = (X :/\: Y) :/\: Z.
Axiom binintersect_com_Subq: forall X Y:set, X :/\: Y c= Y :/\: X.
Axiom binintersect_com: forall X Y:set, X :/\: Y = Y :/\: X.
Axiom binintersect_annil:forall X:set, Empty :/\: X = Empty.
Axiom binintersect_annir:forall X:set, X :/\: Empty = Empty.
Axiom binintersect_idem:forall X:set, X :/\: X = X.
Axiom binintersect_binunion_distr:forall X Y Z:set, X :/\: (Y :\/: Z) = X :/\: Y :\/: X :/\: Z.
Axiom binunion_binintersect_distr:forall X Y Z:set, X :\/: Y :/\: Z = (X :\/: Y) :/\: (X :\/: Z).
Axiom Subq_binintersection_eq:forall X Y:set, (X c= Y) = (X :/\: Y = X).
Axiom binintersect_nIn_I1 : forall X Y z:set, z /:e X -> z /:e X :/\: Y.
Axiom binintersect_nIn_I2 : forall X Y z:set, z /:e Y -> z /:e X :/\: Y.
Axiom binintersect_nIn_E : forall X Y z:set, z /:e X :/\: Y -> z /:e X \/ z /:e Y.

(* Parameter setminus "ab8fa98efe29083fe30a0fab65506354f55a312c53182074393bc5eb5aed1e5d" "cd8574867c700d5542bfe0bb1ed35fc4e5b530a086f5485ba1fb0b5ca87b38b2" *)
Parameter setminus:set->set->set.

(* Unicode :\: "2216" *)
Infix :\: 350 := setminus.

Axiom setminusI:forall X Y z, (z :e X) -> (z /:e Y) -> z :e X :\: Y.
Axiom setminusE:forall X Y z, (z :e X :\: Y) -> z :e X /\ z /:e Y.
Axiom setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
Axiom setminusE2:forall X Y z, (z :e X :\: Y) -> z /:e Y.
Axiom setminus_Subq:forall X Y:set, X :\: Y c= X.
Axiom setminus_Subq_contra:forall X Y Z:set, Z c= Y -> X :\: Y c= X :\: Z.
Axiom setminus_nIn_I1: forall X Y z, z /:e X -> z /:e X :\: Y.
Axiom setminus_nIn_I2: forall X Y z, z :e Y -> z /:e X :\: Y.
Axiom setminus_nIn_E: forall X Y z, z /:e X :\: Y -> z /:e X \/ z :e Y.
Axiom setminus_selfannih:forall X:set, (X :\: X) = Empty.
Axiom setminus_binintersect:forall X Y Z:set, X :\: Y :/\: Z = (X :\: Y) :\/: (X :\: Z).
Axiom setminus_binunion:forall X Y Z:set, X :\: Y :\/: Z = (X :\: Y) :\: Z.
Axiom binintersect_setminus:forall X Y Z:set, (X :/\: Y) :\: Z = X :/\: (Y :\: Z).
Axiom binunion_setminus:forall X Y Z:set, X :\/: Y :\: Z = (X :\: Z) :\/: (Y :\: Z).
Axiom setminus_setminus:forall X Y Z:set, X :\: (Y :\: Z) = (X :\: Y) :\/: (X :/\: Z).
Axiom setminus_annil:forall X:set, Empty :\: X = Empty.
Axiom setminus_idr:forall X:set, X :\: Empty = X.

Axiom neq_0_1 : 0 <> 1.
Axiom neq_0_2 : 0 <> 2.
Axiom neq_1_2 : 1 <> 2.
Axiom nIn_0_0 : 0 /:e 0.
Axiom nIn_1_0 : 1 /:e 0.
Axiom nIn_2_0 : 2 /:e 0.
Axiom nIn_1_1 : 1 /:e 1.
Axiom nIn_2_2 : 2 /:e 2.
Axiom Subq_0_0 : 0 c= 0.
Axiom Subq_0_1 : 0 c= 1.
Axiom Subq_0_2 : 0 c= 2.
Axiom nSubq_1_0 : 1 /c= 0.
Axiom Subq_1_1 : 1 c= 1.
Axiom Subq_1_2 : 1 c= 2.
Axiom nSubq_2_0 : 2 /c= 0.
Axiom nSubq_2_1 : 2 /c= 1.
Axiom Subq_2_2 : 2 c= 2.
Axiom Union_ordsucc_eq : forall n, nat_p n -> Union (ordsucc n) = n.
Axiom In_0_3: 0 :e 3.
Axiom In_1_3: 1 :e 3.
Axiom In_2_3: 2 :e 3.
Axiom In_0_4: 0 :e 4.
Axiom In_1_4: 1 :e 4.
Axiom In_2_4: 2 :e 4.
Axiom In_3_4: 3 :e 4.
Axiom In_0_5: 0 :e 5.
Axiom In_1_5: 1 :e 5.
Axiom In_2_5: 2 :e 5.
Axiom In_3_5: 3 :e 5.
Axiom In_4_5: 4 :e 5.
Axiom In_0_6: 0 :e 6.
Axiom In_1_6: 1 :e 6.
Axiom In_2_6: 2 :e 6.
Axiom In_3_6: 3 :e 6.
Axiom In_4_6: 4 :e 6.
Axiom In_5_6: 5 :e 6.
Axiom In_0_7: 0 :e 7.
Axiom In_1_7: 1 :e 7.
Axiom In_2_7: 2 :e 7.
Axiom In_3_7: 3 :e 7.
Axiom In_4_7: 4 :e 7.
Axiom In_5_7: 5 :e 7.
Axiom In_6_7: 6 :e 7.
Axiom In_0_8: 0 :e 8.
Axiom In_1_8: 1 :e 8.
Axiom In_2_8: 2 :e 8.
Axiom In_3_8: 3 :e 8.
Axiom In_4_8: 4 :e 8.
Axiom In_5_8: 5 :e 8.
Axiom In_6_8: 6 :e 8.
Axiom In_7_8: 7 :e 8.
Axiom In_0_9: 0 :e 9.
Axiom In_1_9: 1 :e 9.
Axiom In_2_9: 2 :e 9.
Axiom In_3_9: 3 :e 9.
Axiom In_4_9: 4 :e 9.
Axiom In_5_9: 5 :e 9.
Axiom In_6_9: 6 :e 9.
Axiom In_7_9: 7 :e 9.
Axiom In_8_9: 8 :e 9.

Section NatRec.

Variable z:set.
Variable f:set->set->set.
Let F : set->(set->set)->set := fun n g => if Union n :e n then f (Union n) (g (Union n)) else z.

Definition nat_primrec : set->set := In_rec_i F.

Axiom nat_primrec_r : forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.

Axiom nat_primrec_0 : nat_primrec 0 = z.

Axiom nat_primrec_S : forall n:set, nat_p n -> nat_primrec (ordsucc n) = f n (nat_primrec n).

End NatRec.

Section NatArith.

Definition add_nat : set->set->set := fun n m:set => nat_primrec n (fun _ r => ordsucc r) m.

Infix + 360 right := add_nat.

Axiom add_nat_0R : forall n:set, n + 0 = n.

Axiom add_nat_SR : forall n m:set, nat_p m -> n + ordsucc m = ordsucc (n + m).

Axiom add_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n + m).

Axiom add_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n+m)+k = n+(m+k).

Axiom add_nat_0L : forall m:set, nat_p m -> 0+m = m.

Axiom add_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n + m = ordsucc (n+m).

Axiom add_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n + m = m + n.

Definition mul_nat : set->set->set := fun n m:set => nat_primrec 0 (fun _ r => n + r) m.

Infix * 355 right := mul_nat.

Axiom mul_nat_0R : forall n:set, n * 0 = 0.

Axiom mul_nat_SR : forall n m:set, nat_p m -> n * ordsucc m = n + n * m.

Axiom mul_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n * m).

Axiom mul_nat_0L : forall m:set, nat_p m -> 0 * m = 0.

Axiom mul_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n * m = n * m + m.

Axiom mul_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n * m = m * n.

Axiom mul_add_nat_distrL : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> n * (m + k) = n * m + n * k.

Axiom mul_add_nat_distrR : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n + m) * k = n * k + m * k.

Axiom mul_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n*m)*k = n*(m*k).

Axiom add_nat_1_1_2 : 1 + 1 = 2.

End NatArith.

Axiom PigeonHole_nat : forall n, nat_p n -> forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).

Axiom PigeonHole_nat_bij : forall n, nat_p n -> forall f:set -> set, (forall i :e n, f i :e n) -> (forall i j :e n, f i = f j -> i = j) -> bij n n f.

Axiom cases_1: forall i :e 1, forall p:set->prop, p 0 -> p i.
Axiom cases_2: forall i :e 2, forall p:set->prop, p 0 -> p 1 -> p i.
Axiom cases_3: forall i :e 3, forall p:set->prop, p 0 -> p 1 -> p 2 -> p i.
Axiom cases_4: forall i :e 4, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p i.
Axiom cases_5: forall i :e 5, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p i.
Axiom cases_6: forall i :e 6, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p i.
Axiom cases_7: forall i :e 7, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p 6 -> p i.
Axiom cases_8: forall i :e 8, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p 6 -> p 7 -> p i.
Axiom cases_9: forall i :e 9, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p 6 -> p 7 -> p 8 -> p i.

Axiom neq_1_0 : 1 <> 0.
Axiom neq_2_0 : 2 <> 0.
Axiom neq_2_1 : 2 <> 1.
Axiom nIn_2_1 : 2 /:e 1.
Axiom neq_3_0: 3 <> 0.
Axiom neq_3_1: 3 <> 1.
Axiom neq_3_2: 3 <> 2.
Axiom neq_4_0: 4 <> 0.
Axiom neq_4_1: 4 <> 1.
Axiom neq_4_2: 4 <> 2.
Axiom neq_4_3: 4 <> 3.
Axiom neq_5_0: 5 <> 0.
Axiom neq_5_1: 5 <> 1.
Axiom neq_5_2: 5 <> 2.
Axiom neq_5_3: 5 <> 3.
Axiom neq_5_4: 5 <> 4.
Axiom neq_6_0: 6 <> 0.
Axiom neq_6_1: 6 <> 1.
Axiom neq_6_2: 6 <> 2.
Axiom neq_6_3: 6 <> 3.
Axiom neq_6_4: 6 <> 4.
Axiom neq_6_5: 6 <> 5.
Axiom neq_7_0: 7 <> 0.
Axiom neq_7_1: 7 <> 1.
Axiom neq_7_2: 7 <> 2.
Axiom neq_7_3: 7 <> 3.
Axiom neq_7_4: 7 <> 4.
Axiom neq_7_5: 7 <> 5.
Axiom neq_7_6: 7 <> 6.
Axiom neq_8_0: 8 <> 0.
Axiom neq_8_1: 8 <> 1.
Axiom neq_8_2: 8 <> 2.
Axiom neq_8_3: 8 <> 3.
Axiom neq_8_4: 8 <> 4.
Axiom neq_8_5: 8 <> 5.
Axiom neq_8_6: 8 <> 6.
Axiom neq_8_7: 8 <> 7.
Axiom neq_9_0: 9 <> 0.
Axiom neq_9_1: 9 <> 1.
Axiom neq_9_2: 9 <> 2.
Axiom neq_9_3: 9 <> 3.
Axiom neq_9_4: 9 <> 4.
Axiom neq_9_5: 9 <> 5.
Axiom neq_9_6: 9 <> 6.
Axiom neq_9_7: 9 <> 7.
Axiom neq_9_8: 9 <> 8.
Axiom Subq_1_Sing0 : 1 c= {0}.
Axiom Subq_Sing0_1 : {0} c= 1.
Axiom eq_1_Sing0 : 1 = {0}.
Axiom Subq_2_UPair01 : 2 c= {0,1}.
Axiom Subq_UPair01_2 : {0,1} c= 2.
Axiom eq_2_UPair01 : 2 = {0,1}.
Axiom ordinal_ind : forall p:set->prop, 
(forall alpha, ordinal alpha -> (forall beta :e alpha, p beta) -> p alpha)
->
forall alpha, ordinal alpha -> p alpha.

Axiom least_ordinal_ex : forall p:set -> prop, (exists alpha, ordinal alpha /\ p alpha) -> exists alpha, ordinal alpha /\ p alpha /\ forall beta :e alpha, ~p beta.

Axiom ordinal_1 : ordinal 1.
Axiom ordinal_2 : ordinal 2.

Axiom omega_TransSet : TransSet omega.
Axiom omega_ordinal : ordinal omega.

Axiom ordsucc_omega_ordinal: ordinal (ordsucc omega).
Axiom TransSet_ordsucc_In_Subq : forall X:set, TransSet X -> forall x :e X, ordsucc x c= X.

Axiom ordinal_ordsucc_In_Subq : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta c= alpha.
Axiom ordinal_trichotomy_or : forall alpha beta:set, ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
   
Axiom ordinal_trichotomy : forall alpha beta:set,
 ordinal alpha -> ordinal beta -> exactly1of3 (alpha :e beta) (alpha = beta) (beta :e alpha).

Axiom ordinal_In_Or_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha :e beta \/ beta c= alpha.
Axiom ordinal_linear : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta \/ beta c= alpha.

Axiom ordinal_ordsucc_In_eq : forall alpha beta, ordinal alpha -> beta :e alpha -> ordsucc beta :e alpha \/ alpha = ordsucc beta.
Axiom ordinal_lim_or_succ : forall alpha, ordinal alpha -> (forall beta :e alpha, ordsucc beta :e alpha) \/ (exists beta :e alpha, alpha = ordsucc beta).

Axiom ordinal_ordsucc_In : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta :e ordsucc alpha.

Axiom ordinal_Union : forall X, (forall x :e X, ordinal x) -> ordinal (Union X).

Axiom ordinal_famunion : forall X, forall F:set -> set, (forall x :e X, ordinal (F x)) -> ordinal (\/_ x :e X, F x).

Axiom ordinal_binintersect : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :/\: beta).

Axiom ordinal_binunion : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :\/: beta).

Axiom ordinal_Sep : forall alpha, ordinal alpha -> forall p:set -> prop, (forall beta :e alpha, forall gamma :e beta, p beta -> p gamma) -> ordinal {beta :e alpha|p beta}.

(*** Injection of set into itself that will correspond to x |-> (1,x) after pairing is defined. ***)
Definition Inj1 : set -> set := In_rec_i (fun X f => {0} :\/: {f x|x :e X}).

Axiom Inj1_eq : forall X:set, Inj1 X = {0} :\/: {Inj1 x|x :e X}.
Axiom Inj1I1 : forall X:set, 0 :e Inj1 X.
Axiom Inj1I2 : forall X x:set, x :e X -> Inj1 x :e Inj1 X.
Axiom Inj1E : forall X y:set, y :e Inj1 X -> y = 0 \/ exists x :e X, y = Inj1 x.
Axiom Inj1NE1 : forall x:set, Inj1 x <> 0.
Axiom Inj1NE2 : forall x:set, Inj1 x /:e {0}.

(*** Injection of set into itself that will correspond to x |-> (0,x) after pairing is defined. ***)
Definition Inj0 : set -> set := fun X => {Inj1 x|x :e X}.

Axiom Inj0I : forall X x:set, x :e X -> Inj1 x :e Inj0 X.
Axiom Inj0E : forall X y:set, y :e Inj0 X -> exists x:set, x :e X /\ y = Inj1 x.

(*** Unj : Left inverse of Inj1 and Inj0 ***)
Definition Unj : set -> set := In_rec_i (fun X f => {f x|x :e X :\: {0}}).

Axiom Unj_eq : forall X:set, Unj X = {Unj x|x :e X :\: {0}}.
Axiom Unj_Inj1_eq : forall X:set, Unj (Inj1 X) = X.
Axiom Inj1_inj : forall X Y:set, Inj1 X = Inj1 Y -> X = Y.
Axiom Unj_Inj0_eq : forall X:set, Unj (Inj0 X) = X.
Axiom Inj0_inj : forall X Y:set, Inj0 X = Inj0 Y -> X = Y.
Axiom Inj0_0 : Inj0 0 = 0.
Axiom Inj0_Inj1_neq : forall X Y:set, Inj0 X <> Inj1 Y.

(*** setsum ***)
Definition setsum : set -> set -> set := fun X Y => {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.

(* Unicode :+: "002b" *)
Infix :+: 450 left := setsum.

Axiom Inj0_setsum : forall X Y x:set, x :e X -> Inj0 x :e X :+: Y.
Axiom Inj1_setsum : forall X Y y:set, y :e Y -> Inj1 y :e X :+: Y.
Axiom setsum_Inj_inv : forall X Y z:set, z :e X :+: Y -> (exists x :e X, z = Inj0 x) \/ (exists y :e Y, z = Inj1 y).

Axiom Inj0_setsum_0L : forall X:set, 0 :+: X = Inj0 X.
Axiom Inj1_setsum_1L : forall X:set, 1 :+: X = Inj1 X.
Axiom nat_setsum1_ordsucc : forall n:set, nat_p n -> 1 :+: n = ordsucc n.
Axiom setsum_0_0 : 0 :+: 0 = 0.
Axiom setsum_1_0_1 : 1 :+: 0 = 1.
Axiom setsum_1_1_2 : 1 :+: 1 = 2.
Axiom setsum_mon : forall X Y W Z, X c= W -> Y c= Z -> X :+: Y c= W :+: Z.

Definition combine_funcs : set -> set -> (set -> set) -> (set -> set) -> set -> set :=
  fun X Y f g z =>
   if z = Inj0 (Unj z) then f (Unj z) else g (Unj z).

Axiom combine_funcs_eq1 : forall X Y, forall f g:set -> set,
  forall x, combine_funcs X Y f g (Inj0 x) = f x.

Axiom combine_funcs_eq2 : forall X Y, forall f g:set -> set,
  forall y, combine_funcs X Y f g (Inj1 y) = g y.

Section pair_setsum.

Let pair := setsum.

Axiom pair_0_0 : pair 0 0 = 0.
Axiom pair_1_0_1 : pair 1 0 = 1.
Axiom pair_1_1_2 : pair 1 1 = 2.
Axiom nat_pair1_ordsucc : forall n:set, nat_p n -> pair 1 n = ordsucc n.

Definition proj0 : set -> set := fun Z => {Unj z|z :e Z, exists x:set, Inj0 x = z}.
Definition proj1 : set -> set := fun Z => {Unj z|z :e Z, exists y:set, Inj1 y = z}.

Axiom Inj0_pair_0_eq : Inj0 = pair 0.
Axiom Inj1_pair_1_eq : Inj1 = pair 1.
Axiom pairI0 : forall X Y x, x :e X -> pair 0 x :e pair X Y.
Axiom pairI1 : forall X Y y, y :e Y -> pair 1 y :e pair X Y.
Axiom pairE : forall X Y z, z :e pair X Y -> (exists x :e X, z = pair 0 x) \/ (exists y :e Y, z = pair 1 y).
Axiom pairE0 : forall X Y x, pair 0 x :e pair X Y -> x :e X.
Axiom pairE1 : forall X Y y, pair 1 y :e pair X Y -> y :e Y.
Axiom pairEq : forall X Y z, z :e pair X Y <-> (exists x :e X, z = pair 0 x) \/ (exists y :e Y, z = pair 1 y).
Axiom pairSubq : forall X Y W Z, X c= W -> Y c= Z -> pair X Y c= pair W Z.
Axiom proj0I : forall w u:set, pair 0 u :e w -> u :e proj0 w.
Axiom proj0E : forall w u:set, u :e proj0 w -> pair 0 u :e w.
Axiom proj1I : forall w u:set, pair 1 u :e w -> u :e proj1 w.
Axiom proj1E : forall w u:set, u :e proj1 w -> pair 1 u :e w.
Axiom proj0_pair_eq : forall X Y:set, proj0 (pair X Y) = X.
Axiom proj1_pair_eq : forall X Y:set, proj1 (pair X Y) = Y.
Axiom pair_inj : forall x y w z:set, pair x y = pair w z -> x = w /\ y = z.
Axiom pair_eta_Subq_proj : forall w, pair (proj0 w) (proj1 w) c= w.

(*** Sigma X Y = {(x,y) | x in X, y in Y x} ***)
Definition Sigma : set -> (set -> set) -> set :=
fun X Y => \/_ x :e X, {pair x y|y :e Y x}.

(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.

Axiom pair_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, pair x y :e Sigma_ x :e X, Y x.

Axiom Sigma_eta_proj0_proj1 : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (proj0 z) (proj1 z) = z /\ proj0 z :e X /\ proj1 z :e Y (proj0 z).

Axiom proj_Sigma_eta : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (proj0 z) (proj1 z) = z.

Axiom proj0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj0 z :e X.

Axiom proj1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj1 z :e Y (proj0 z).

Axiom pair_Sigma_E0 : forall X:set, forall Y:set->set, forall x y:set, pair x y :e (Sigma_ x :e X, Y x) -> x :e X.

Axiom pair_Sigma_E1 : forall X:set, forall Y:set->set, forall x y:set, pair x y :e (Sigma_ x :e X, Y x) -> y :e Y x.

Axiom Sigma_E : forall X:set, forall Y:set->set, forall z:set, z :e (Sigma_ x :e X, Y x) -> exists x :e X, exists y :e Y x, z = pair x y.

Axiom Sigma_Eq : forall X:set, forall Y:set->set, forall z:set, z :e (Sigma_ x :e X, Y x) <-> exists x :e X, exists y :e Y x, z = pair x y.

(*** Covariance of subsets of Sigmas ***)
Axiom Sigma_mon : forall X Y:set, X c= Y -> forall Z W:set->set, (forall x :e X, Z x c= W x) -> (Sigma_ x :e X, Z x) c= Sigma_ y :e Y, W y.

Axiom Sigma_mon0 : forall X Y:set, X c= Y -> forall Z:set->set, (Sigma_ x :e X, Z x) c= Sigma_ y :e Y, Z y.

Axiom Sigma_mon1 : forall X:set, forall Z W:set->set, (forall x, x :e X -> Z x c= W x) -> (Sigma_ x :e X, Z x) c= Sigma_ x :e X, W x.

Axiom Sigma_Power_1 : forall X:set, X :e Power 1 -> forall Y:set->set, (forall x :e X, Y x :e Power 1) -> (Sigma_ x :e X, Y x) :e Power 1.

Definition setprod : set->set->set := fun X Y:set => Sigma_ x :e X, Y.

(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.

Axiom pair_setprod : forall X Y:set, forall (x :e X) (y :e Y), pair x y :e X :*: Y.

Axiom proj0_setprod : forall X Y:set, forall z :e X :*: Y, proj0 z :e X.

Axiom proj1_setprod : forall X Y:set, forall z :e X :*: Y, proj1 z :e Y.

Axiom pair_setprod_E0 : forall X Y x y:set, pair x y :e X :*: Y -> x :e X.

Axiom pair_setprod_E1 : forall X Y x y:set, pair x y :e X :*: Y -> y :e Y.

(*** lam X F = {(x,y) | x :e X, y :e F x} = \/_{x :e X} {(x,y) | y :e (F x)} = Sigma X F ***)
Let lam : set -> (set -> set) -> set := Sigma.

(***  ap f x = {proj1 z | z :e f,  exists y, z = pair x y}} ***)
Definition ap : set -> set -> set := fun f x => {proj1 z|z :e f, exists y:set, z = pair x y}.

Notation SetImplicitOp ap.
Notation SetLam Sigma.

Axiom lamI : forall X:set, forall F:set->set, forall x :e X, forall y :e F x, pair x y :e fun x :e X => F x.

Axiom lamE : forall X:set, forall F:set->set, forall z:set, z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = pair x y.

Axiom lamEq : forall X:set, forall F:set->set, forall z, z :e (fun x :e X => F x) <-> exists x :e X, exists y :e F x, z = pair x y.

Axiom apI : forall f x y, pair x y :e f -> y :e f x.

Axiom apE : forall f x y, y :e f x -> pair x y :e f.

Axiom apEq : forall f x y, y :e f x <-> pair x y :e f.

Axiom beta : forall X:set, forall F:set -> set, forall x:set, x :e X -> (fun x :e X => F x) x = F x.

Axiom beta0 : forall X:set, forall F:set -> set, forall x:set, x /:e X -> (fun x :e X => F x) x = 0.

Axiom proj0_ap_0 : forall u, proj0 u = u 0.

Axiom proj1_ap_1 : forall u, proj1 u = u 1.

Axiom pair_ap_0 : forall x y:set, (pair x y) 0 = x.

Axiom pair_ap_1 : forall x y:set, (pair x y) 1 = y.

Axiom pair_ap_n2 : forall x y i:set, i /:e 2 -> (pair x y) i = 0.

Axiom ap0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 0) :e X.

Axiom ap1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 1) :e (Y (z 0)).

Definition pair_p:set->prop
:= fun u:set => pair (u 0) (u 1) = u.

Axiom pair_p_I : forall x y, pair_p (pair x y).

Axiom pair_p_I2 : forall w, (forall u :e w, pair_p u /\ u 0 :e 2) -> pair_p w.

Axiom pair_p_In_ap : forall w f, pair_p w -> w :e f -> w 1 :e ap f (w 0).

Definition tuple_p : set->set->prop :=
fun n u => forall z :e u, exists i :e n, exists x:set, z = pair i x.

Axiom pair_p_tuple2 : pair_p = tuple_p 2.

Axiom tuple_p_2_tuple : forall x y:set, tuple_p 2 (x,y).

Axiom tuple_pair : forall x y:set, pair x y = (x,y).

Definition Pi : set -> (set -> set) -> set := fun X Y => {f :e Power (Sigma_ x :e X, Union (Y x)) | forall x :e X, f x :e Y x}.

(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.

Axiom PiI : forall X:set, forall Y:set->set, forall f:set,
    (forall u :e f, pair_p u /\ u 0 :e X) -> (forall x :e X, f x :e Y x) -> f :e Pi_ x :e X, Y x.

Axiom PiE : forall X:set, forall Y:set->set, forall f:set,
  f :e (Pi_ x :e X, Y x) -> (forall u :e f, pair_p u /\ u 0 :e X) /\ (forall x :e X, f x :e Y x).

Axiom PiEq : forall X:set, forall Y:set->set, forall f:set,
    f :e Pi X Y <-> (forall u :e f, pair_p u /\ u 0 :e X) /\ (forall x :e X, f x :e Y x).

Axiom lam_Pi : forall X:set, forall Y:set -> set, forall F:set -> set,
 (forall x :e X, F x :e Y x) -> (fun x :e X => F x) :e (Pi_ x :e X, Y x).

Axiom ap_Pi : forall X:set, forall Y:set -> set, forall f:set, forall x:set, f :e (Pi_ x :e X, Y x) -> x :e X -> f x :e Y x.

Axiom Pi_ext_Subq : forall X:set, forall Y:set -> set, forall f g :e (Pi_ x :e X, Y x), (forall x :e X, f x c= g x) -> f c= g.

Axiom Pi_ext : forall X:set, forall Y:set -> set, forall f g :e (Pi_ x :e X, Y x), (forall x :e X, f x = g x) -> f = g.

Axiom Pi_eta : forall X:set, forall Y:set -> set, forall f:set, f :e (Pi_ x :e X, Y x) -> (fun x :e X => f x) = f.

Definition setexp : set->set->set := fun X Y:set => Pi_ y :e Y, X.

(* Superscript :^: *)
Infix :^: 430 left := setexp.

Axiom pair_tuple_fun : pair = (fun x y => (x,y)).

Axiom lamI2 : forall X, forall F:set->set, forall x :e X, forall y :e F x, (x,y) :e fun x :e X => F x.

Axiom lamE2 : forall X, forall F : set -> set , forall z : set , z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = (x,y).

Axiom tuple_2_inj : forall x y w z:set, (x,y) = (w,z) -> x = w /\ y = z.

Section Tuples.

Variable x0 x1: set.
Axiom tuple_2_0_eq: (x0,x1) 0 = x0.

Axiom tuple_2_1_eq: (x0,x1) 1 = x1.

End Tuples.

Definition Sep2 : set -> (set -> set) -> (set -> set -> prop) -> set
 := fun X Y R => {u :e Sigma_ x :e X, Y x | R (u 0) (u 1)}.

Axiom Sep2I: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x :e X, forall y :e Y x, R x y -> (x,y) :e Sep2 X Y R.

Axiom Sep2E: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall u :e Sep2 X Y R, exists x :e X, exists y :e Y x, u = (x,y) /\ R x y.

Axiom Sep2E': forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> x :e X /\ y :e Y x /\ R x y.

Axiom Sep2E'1: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> x :e X.

Axiom Sep2E'2: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> y :e Y x.

Axiom Sep2E'3: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> R x y.

Definition set_of_pairs : set -> prop := fun X => forall x :e X, exists y z, x = (y,z).

Axiom set_of_pairs_ext : forall X Y,
     set_of_pairs X -> set_of_pairs Y
  -> (forall v w, (v,w) :e X <-> (v,w) :e Y)
  -> X = Y.

Axiom Sep2_set_of_pairs : forall X, forall Y:set -> set, forall R:set -> set -> prop,
   set_of_pairs (Sep2 X Y R).

Axiom Sep2_ext : forall X, forall Y:set -> set, forall R R':set -> set -> prop,
     (forall x :e X, forall y :e Y x, R x y <-> R' x y)
  -> Sep2 X Y R = Sep2 X Y R'.

Axiom lam_ext_sub: forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> (fun x :e X => F x) c= (fun x :e X => G x).

Axiom lam_ext: forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> (fun x :e X => F x) = (fun x :e X => G x).

Axiom lam_eta: forall X, forall F:set -> set, (fun x :e X => (fun x :e X => F x) x) = (fun x :e X => F x).

Axiom tuple_2_eta : forall x y, (fun i :e 2 => (x,y) i) = (x,y).

Definition lam2 : set -> (set -> set) -> (set -> set -> set) -> set
 := fun X Y F => fun x :e X => fun y :e Y x => F x y.

Axiom beta2 : forall X, forall Y:set -> set, forall F:set->set->set, forall x :e X, forall y :e Y x, lam2 X Y F x y = F x y.

Axiom lam2_ext: forall X, forall Y:set -> set, forall F G:set -> set -> set,
     (forall x :e X, forall y :e Y x, F x y = G x y)
  -> lam2 X Y F = lam2 X Y G.

Definition encode_u : set -> (set -> set) -> set := lam.
Definition decode_u : set -> set -> set := ap.

Definition encode_b : set -> (set -> set -> set) -> set := fun X F => lam2 X (fun _ => X) F.
Definition decode_b : set -> set -> set -> set := fun F x y => F x y.

Definition encode_p : set -> (set -> prop) -> set := fun X P => Sep X P.
Definition decode_p : set -> set -> prop := fun P x => x :e P.

Definition encode_r : set -> (set -> set -> prop) -> set := fun X R => Sep2 X (fun _ => X) R.
Definition decode_r : set -> set -> set -> prop := fun R x y => (x,y) :e R.

Definition encode_c : set -> ((set -> prop) -> prop) -> set := fun X C => Sep (Power X) (fun U => (C (fun x => x :e U))).
Definition decode_c : set -> (set -> prop) -> prop := fun C U => exists V, (forall x, U x <-> x :e V) /\ V :e C.

Axiom decode_encode_u : forall X, forall F:set -> set, forall x :e X, decode_u (encode_u X F) x = F x.

Axiom encode_u_ext : forall X, forall F F':set -> set, (forall x :e X, F x = F' x) -> encode_u X F = encode_u X F'.

Axiom decode_encode_b : forall X, forall F:set -> set -> set, forall x y :e X, decode_b (encode_b X F) x y = F x y.

Axiom encode_b_ext : forall X, forall F F':set -> set -> set, (forall x y :e X, F x y = F' x y) -> encode_b X F = encode_b X F'.

Axiom decode_encode_p : forall X, forall P:set -> prop, forall x :e X, (decode_p (encode_p X P) x) = (P x).

Axiom encode_p_ext : forall X, forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> encode_p X P = encode_p X P'.

Axiom decode_encode_r : forall X, forall R:set -> set -> prop, forall x y :e X, (decode_r (encode_r X R) x y) = (R x y).

Axiom encode_r_ext : forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> encode_r X R = encode_r X R'.

Axiom decode_encode_c : forall X, forall C:(set -> prop) -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> (decode_c (encode_c X C) U) = (C U).

Axiom encode_c_ext : forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) -> encode_c X C = encode_c X C'.

Axiom setprod_mon : forall X Y:set, X c= Y -> forall Z W:set, Z c= W -> X :*: Z c= Y :*: W.

Axiom setprod_mon0 : forall X Y:set, X c= Y -> forall Z:set, X :*: Z c= Y :*: Z.

Axiom setprod_mon1 : forall X:set, forall Z W:set, Z c= W -> X :*: Z c= X :*: W.

Axiom pair_eta_Subq : forall w, pair (w 0) (w 1) c= w.

Axiom Sigma_eta : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (z 0) (z 1) = z.

Axiom ReplEq_setprod_ext : forall X Y, forall F G:set -> set -> set, (forall x :e X, forall y :e Y, F x y = G x y) -> {F (w 0) (w 1)|w :e X :*: Y} = {G (w 0) (w 1)|w :e X :*: Y}.

Axiom tuple_p_3_tuple : forall x y z:set, tuple_p 3 (x,y,z).

Axiom tuple_p_4_tuple : forall x y z w:set, tuple_p 4 (x,y,z,w).

Axiom Pi_Power_1 : forall X:set, forall Y:set->set, (forall x :e X, Y x :e Power 1) -> (Pi_ x :e X, Y x) :e Power 1.

Axiom Pi_0_dom_mon : forall X Y:set, forall A:set->set, X c= Y -> (forall y :e Y, y /:e X -> 0 :e A y)
 -> (Pi_ x :e X, A x) c= Pi_ y :e Y, A y.

Axiom Pi_cod_mon : forall X:set, forall A B:set->set, (forall x :e X, A x c= B x) -> (Pi_ x :e X, A x) c= Pi_ x :e X, B x.

Axiom Pi_0_mon : forall X Y:set, forall A B:set->set,
 (forall x :e X, A x c= B x) -> X c= Y -> (forall y :e Y, y /:e X -> 0 :e B y)
 -> (Pi_ x :e X, A x) c= Pi_ y :e Y, B y.

Axiom setexp_2_eq : forall X:set, X :*: X = X :^: 2.

Axiom setexp_0_dom_mon : forall A:set, 0 :e A -> forall X Y:set, X c= Y -> A :^: X c= A :^: Y.

Axiom setexp_0_mon : forall X Y A B:set, 0 :e B -> A c= B -> X c= Y -> A :^: X c= B :^: Y.

Axiom nat_in_setexp_mon : forall A:set, 0 :e A -> forall n, nat_p n -> forall m :e n, A :^: m c= A :^: n.

Axiom tupleI0 : forall X Y x, x :e X -> (0,x) :e (X,Y).

Axiom tupleI1 : forall X Y y, y :e Y -> (1,y) :e (X,Y).

Axiom tupleE : forall X Y z, z :e (X,Y) -> (exists x :e X, z = (0,x)) \/ (exists y :e Y, z = (1,y)).

Axiom tuple_2_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, (x,y) :e Sigma_ x :e X, Y x.

Axiom tuple_2_setprod : forall X:set, forall Y:set, forall x :e X, forall y :e Y, (x,y) :e X :*: Y.

Axiom tuple_Sigma_eta : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), (z 0,z 1) = z.

Axiom apI2 : forall f x y, (x,y) :e f -> y :e f x.

Axiom apE2 : forall f x y, y :e f x -> (x,y) :e f.

Axiom ap_const_0 : forall x, 0 x = 0.

Axiom tuple_2_in_A_2 : forall x y A, x :e A -> y :e A -> (x,y) :e A :^: 2.

Axiom tuple_2_bij_2 : forall x y, x :e 2 -> y :e 2 -> x <> y -> bij 2 2 (fun i => (x,y) i).

Axiom tuple_3_eta : forall x y z, (fun i :e 3 => (x,y,z) i) = (x,y,z).

Axiom tuple_4_eta : forall x y z w, (fun i :e 4 => (x,y,z,w) i) = (x,y,z,w).

Section Tuples.

Variable x0 x1 x2: set.

Axiom tuple_3_0_eq: (x0,x1,x2) 0 = x0.

Axiom tuple_3_1_eq: (x0,x1,x2) 1 = x1.

Axiom tuple_3_2_eq: (x0,x1,x2) 2 = x2.

Variable x3: set.
Axiom tuple_4_0_eq: (x0,x1,x2,x3) 0 = x0.

Axiom tuple_4_1_eq: (x0,x1,x2,x3) 1 = x1.

Axiom tuple_4_2_eq: (x0,x1,x2,x3) 2 = x2.

Axiom tuple_4_3_eq: (x0,x1,x2,x3) 3 = x3.

Variable x4: set.

Axiom tuple_5_0_eq: (x0,x1,x2,x3,x4) 0 = x0.

Axiom tuple_5_1_eq: (x0,x1,x2,x3,x4) 1 = x1.

Axiom tuple_5_2_eq: (x0,x1,x2,x3,x4) 2 = x2.

Axiom tuple_5_3_eq: (x0,x1,x2,x3,x4) 3 = x3.

Axiom tuple_5_4_eq: (x0,x1,x2,x3,x4) 4 = x4.

Variable x5: set.
Axiom tuple_6_0_eq: (x0,x1,x2,x3,x4,x5) 0 = x0.

Axiom tuple_6_1_eq: (x0,x1,x2,x3,x4,x5) 1 = x1.

Axiom tuple_6_2_eq: (x0,x1,x2,x3,x4,x5) 2 = x2.

Axiom tuple_6_3_eq: (x0,x1,x2,x3,x4,x5) 3 = x3.

Axiom tuple_6_4_eq: (x0,x1,x2,x3,x4,x5) 4 = x4.

Axiom tuple_6_5_eq: (x0,x1,x2,x3,x4,x5) 5 = x5.

Variable x6: set.
Axiom tuple_7_0_eq: (x0,x1,x2,x3,x4,x5,x6) 0 = x0.

Axiom tuple_7_1_eq: (x0,x1,x2,x3,x4,x5,x6) 1 = x1.

Axiom tuple_7_2_eq: (x0,x1,x2,x3,x4,x5,x6) 2 = x2.

Axiom tuple_7_3_eq: (x0,x1,x2,x3,x4,x5,x6) 3 = x3.

Axiom tuple_7_4_eq: (x0,x1,x2,x3,x4,x5,x6) 4 = x4.

Axiom tuple_7_5_eq: (x0,x1,x2,x3,x4,x5,x6) 5 = x5.

Axiom tuple_7_6_eq: (x0,x1,x2,x3,x4,x5,x6) 6 = x6.

Variable x7: set.

Axiom tuple_8_0_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 0 = x0.

Axiom tuple_8_1_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 1 = x1.

Axiom tuple_8_2_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 2 = x2.

Axiom tuple_8_3_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 3 = x3.

Axiom tuple_8_4_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 4 = x4.

Axiom tuple_8_5_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 5 = x5.

Axiom tuple_8_6_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 6 = x6.

Axiom tuple_8_7_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 7 = x7.

Variable x8: set.
Axiom tuple_9_0_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 0 = x0.

Axiom tuple_9_1_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 1 = x1.

Axiom tuple_9_2_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 2 = x2.

Axiom tuple_9_3_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 3 = x3.

Axiom tuple_9_4_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 4 = x4.

Axiom tuple_9_5_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 5 = x5.

Axiom tuple_9_6_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 6 = x6.

Axiom tuple_9_7_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 7 = x7.

Axiom tuple_9_8_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 8 = x8.

End Tuples.

End pair_setsum.

(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.

(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.

(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.

(* Superscript :^: *)
Infix :^: 430 left := setexp.

Axiom tuple_3_in_A_3 : forall x y z A, x :e A -> y :e A -> z :e A -> (x,y,z) :e A :^: 3.

Axiom tuple_3_bij_3 : forall x y z, x :e 3 -> y :e 3 -> z :e 3 -> x <> y -> x <> z -> y <> z -> bij 3 3 (fun i => (x,y,z) i).

Axiom tuple_4_in_A_4 : forall x y z w A, x :e A -> y :e A -> z :e A -> w :e A -> (x,y,z,w) :e A :^: 4.

Axiom tuple_4_bij_4 : forall x y z w, x :e 4 -> y :e 4 -> z :e 4 -> w :e 4 -> x <> y -> x <> z -> x <> w -> y <> z -> y <> w -> z <> w -> bij 4 4 (fun i => (x,y,z,w) i).

Axiom iff_refl : forall A:prop, A <-> A.

Axiom iff_sym : forall A B:prop, (A <-> B) -> (B <-> A).

Axiom iff_trans : forall A B C: prop, (A <-> B) -> (B <-> C) -> (A <-> C).

Axiom not_or_and_demorgan : forall A B:prop, ~(A \/ B) -> ~A /\ ~B.

Axiom and_not_or_demorgan : forall A B:prop, ~A /\ ~B -> ~(A \/ B).

Axiom not_ex_all_demorgan_i : forall P:set->prop, (~exists x, P x) -> forall x, ~P x.

Axiom not_all_ex_demorgan_i : forall P:set->prop, ~(forall x, P x) -> exists x, ~P x.

Axiom eq_or_nand : or = (fun (x y:prop) => ~(~x /\ ~y)).

Definition EpsR_i_i_1 : (set->set->prop) -> set := fun R => the (fun x => exists y, R x y).
Definition EpsR_i_i_2 : (set->set->prop) -> set := fun R => the (fun y => R (EpsR_i_i_1 R) y).

Axiom EpsR_i_i_12 : forall R:set->set->prop, (exists x y, R x y) -> R (EpsR_i_i_1 R) (EpsR_i_i_2 R).

Definition DescrR_i_io_1 : (set->(set->prop)->prop) -> set := fun R => the (fun x => (exists y:set -> prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)).
Definition DescrR_i_io_2 : (set->(set->prop)->prop) -> set->prop := fun R => Descr_Vo1 (fun y => R (DescrR_i_io_1 R) y).

Axiom DescrR_i_io_12 : forall R:set->(set->prop)->prop, (exists x, (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)) -> R (DescrR_i_io_1 R) (DescrR_i_io_2 R).

(** Conway describes this way of formalizing in ZF in an appendix to Part Zero of his book,
    but rejects formalization in favor of "Mathematician's Liberation."
 **)

Definition PNoEq_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => forall beta :e alpha, p beta <-> q beta.

Axiom PNoEq_ref_ : forall alpha, forall p:set -> prop, PNoEq_ alpha p p.

Axiom PNoEq_sym_ : forall alpha, forall p q:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q p.

Axiom PNoEq_tra_ : forall alpha, forall p q r:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q r -> PNoEq_ alpha p r.

Axiom PNoEq_antimon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoEq_ alpha p q -> PNoEq_ beta p q.

Definition PNoLt_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.

Axiom PNoLt_E_ : forall alpha, forall p q:set -> prop, PNoLt_ alpha p q ->
  forall R:prop, (forall beta, beta :e alpha -> PNoEq_ beta p q -> ~p beta -> q beta -> R) -> R.

Axiom PNoLt_irref_ : forall alpha, forall p:set -> prop, ~PNoLt_ alpha p p.

Axiom PNoLt_mon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoLt_ beta p q -> PNoLt_ alpha p q.

Axiom PNoLt_trichotomy_or_ : forall p q:set -> prop, forall alpha, ordinal alpha
  -> PNoLt_ alpha p q \/ PNoEq_ alpha p q \/ PNoLt_ alpha q p.

Axiom PNoLt_tra_ : forall alpha, ordinal alpha -> forall p q r:set -> prop, PNoLt_ alpha p q -> PNoLt_ alpha q r -> PNoLt_ alpha p r.

Definition PNoLt : set -> (set -> prop) -> set -> (set -> prop) -> prop
 := fun alpha p beta q =>
        PNoLt_ (alpha :/\: beta) p q
     \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
     \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.

Axiom PNoLtI1 : forall alpha beta, forall p q:set -> prop,
  PNoLt_ (alpha :/\: beta) p q -> PNoLt alpha p beta q.

Axiom PNoLtI2 : forall alpha beta, forall p q:set -> prop,
  alpha :e beta -> PNoEq_ alpha p q -> q alpha -> PNoLt alpha p beta q.

Axiom PNoLtI3 : forall alpha beta, forall p q:set -> prop,
  beta :e alpha -> PNoEq_ beta p q -> ~p beta -> PNoLt alpha p beta q.

Axiom PNoLtE : forall alpha beta, forall p q:set -> prop,
  PNoLt alpha p beta q ->
  forall R:prop,
      (PNoLt_ (alpha :/\: beta) p q -> R)
   -> (alpha :e beta -> PNoEq_ alpha p q -> q alpha -> R)
   -> (beta :e alpha -> PNoEq_ beta p q -> ~p beta -> R)
   -> R.

Axiom PNoLtE2 : forall alpha, forall p q:set -> prop,
  PNoLt alpha p alpha q -> PNoLt_ alpha p q.

Axiom PNoLt_irref : forall alpha, forall p:set -> prop, ~PNoLt alpha p alpha p.

Axiom PNoLt_trichotomy_or : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q \/ PNoLt beta q alpha p.

Axiom PNoLtEq_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoEq_ beta q r -> PNoLt alpha p beta r.

Axiom PNoEqLt_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLt alpha q beta r -> PNoLt alpha p beta r.

Axiom PNoLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.

Definition PNoLe : set -> (set -> prop) -> set -> (set -> prop) -> prop
   := fun alpha p beta q => PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.

Axiom PNoLeI1 : forall alpha beta, forall p q:set -> prop,
   PNoLt alpha p beta q -> PNoLe alpha p beta q.

Axiom PNoLeI2 : forall alpha, forall p q:set -> prop,
   PNoEq_ alpha p q -> PNoLe alpha p alpha q.

Axiom PNoLe_ref : forall alpha, forall p:set -> prop, PNoLe alpha p alpha p.

Axiom PNoLe_antisym : forall alpha beta, ordinal alpha -> ordinal beta ->
 forall p q:set -> prop,
 PNoLe alpha p beta q -> PNoLe beta q alpha p -> alpha = beta /\ PNoEq_ alpha p q.

Axiom PNoLtLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLe beta q gamma r -> PNoLt alpha p gamma r.

Axiom PNoLeLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.

Axiom PNoEqLe_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLe alpha q beta r -> PNoLe alpha p beta r.

Axiom PNoLeEq_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoEq_ beta q r -> PNoLe alpha p beta r.

Axiom PNoLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLe beta q gamma r -> PNoLe alpha p gamma r.

Definition PNo_downc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun L alpha p => exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe alpha p beta q.

Definition PNo_upc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun R alpha p => exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q alpha p.

Axiom PNoLe_downc : forall L:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_downc L alpha p -> PNoLe beta q alpha p -> PNo_downc L beta q.

Axiom PNo_downc_ref : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, L alpha p -> PNo_downc L alpha p.

Axiom PNo_upc_ref : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, R alpha p -> PNo_upc R alpha p.

Axiom PNoLe_upc : forall R:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_upc R alpha p -> PNoLe alpha p beta q -> PNo_upc R beta q.

Definition PNoLt_pwise : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> prop
  := fun L R => forall gamma, ordinal gamma -> forall p:set -> prop, L gamma p -> forall delta, ordinal delta -> forall q:set -> prop, R delta q -> PNoLt gamma p delta q.

Axiom PNoLt_pwise_downc_upc : forall L R:set -> (set -> prop) -> prop,
    PNoLt_pwise L R -> PNoLt_pwise (PNo_downc L) (PNo_upc R).

Definition PNo_rel_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_downc L beta q -> PNoLt beta q alpha p.

Definition PNo_rel_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_upc R beta q -> PNoLt alpha p beta q.

Definition PNo_rel_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_upperbd L alpha p /\ PNo_rel_strict_lowerbd R alpha p.

Axiom PNoEq_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L alpha q.

Axiom PNo_rel_strict_upperbd_antimon : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.

Axiom PNoEq_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R alpha q.

Axiom PNo_rel_strict_lowerbd_antimon : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.

Axiom PNoEq_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R alpha q.

Axiom PNo_rel_strict_imv_antimon : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.

Definition PNo_rel_strict_uniq_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_imv L R alpha p /\ forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha p q.

Definition PNo_rel_strict_split_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p =>
         PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha)
      /\ PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).

Axiom PNo_extend0_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta /\ delta <> alpha).

Axiom PNo_extend1_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta \/ delta = alpha).

Axiom PNo_rel_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha ->
      (exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p)
   \/ (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).

Definition PNo_lenbdd : set -> (set -> (set -> prop) -> prop) -> prop
  := fun alpha L => forall beta, forall p:set -> prop, L beta p -> beta :e alpha.

Axiom PNo_lenbdd_strict_imv_extend0 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha).

Axiom PNo_lenbdd_strict_imv_extend1 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).

Axiom PNo_lenbdd_strict_imv_split : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_split_imv L R alpha p.

Axiom PNo_rel_imv_bdd_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_rel_strict_split_imv L R beta p.

Definition PNo_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, L beta q -> PNoLt beta q alpha p.

Definition PNo_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, R beta q -> PNoLt alpha p beta q.

Definition PNo_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_strict_upperbd L alpha p /\ PNo_strict_lowerbd R alpha p.

Axiom PNoEq_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_upperbd L alpha p -> PNo_strict_upperbd L alpha q.

Axiom PNoEq_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_lowerbd R alpha p -> PNo_strict_lowerbd R alpha q.

Axiom PNoEq_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_imv L R alpha p -> PNo_strict_imv L R alpha q.

Axiom PNo_strict_upperbd_imp_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.

Axiom PNo_strict_lowerbd_imp_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.

Axiom PNo_strict_imv_imp_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.

Axiom PNo_rel_split_imv_imp_strict_imv : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> forall p:set -> prop,
       PNo_rel_strict_split_imv L R alpha p
    -> PNo_strict_imv L R alpha p.

Axiom ordinal_PNo_strict_imv : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha ->
  forall p:set -> prop, (forall beta :e alpha, p beta) -> 
  (forall beta, ordinal beta -> forall q:set -> prop, L beta q -> beta :e alpha) ->
  (forall beta :e alpha, L beta p) ->
  (forall beta, ordinal beta -> forall q:set -> prop, ~R beta q) ->
  PNo_strict_imv L R alpha p.

Axiom PNo_lenbdd_strict_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_strict_imv L R beta p.

Definition PNo_least_rep : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => ordinal beta
       /\ PNo_strict_imv L R beta p
       /\ forall gamma :e beta,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.

Axiom PNo_lenbdd_least_rep_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta, exists p:set -> prop, PNo_least_rep L R beta p.

Definition PNo_least_rep2 : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => PNo_least_rep L R beta p /\ forall x, x /:e beta -> ~p x.

Axiom PNo_strict_imv_pred_eq : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha -> forall p q:set -> prop,
     PNo_least_rep L R alpha p
  -> PNo_strict_imv L R alpha q
  -> forall beta :e alpha, p beta <-> q beta.

Axiom PNo_lenbdd_least_rep2_exuniq2 : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta,
        (exists p:set -> prop, PNo_least_rep2 L R beta p)
     /\ (forall p q:set -> prop, PNo_least_rep2 L R beta p -> PNo_least_rep2 L R beta q -> p = q).

(* Parameter PNo_bd "e4db582992b58a1e96691e3fdeb7a4f0e2e4537c05d49535dca535d4b6fbfea0" "246404b4e1e510d26ba56b2f381d0a3320fb2191795347af69ef54483286f851" *)
Parameter PNo_bd : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set.

(* Parameter PNo_pred "0366322107205cee179dc9160736ef0dcbea4f3083f5a3b649fd0e2613455d26" "fedeff438e0b134a8c101129148bf10550fab7f93168dd8a3f15c3a760bf9ccb" *)
Parameter PNo_pred : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> prop.

Axiom PNo_bd_pred_lem : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep2 L R (PNo_bd L R) (PNo_pred L R).

Axiom PNo_bd_pred : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep L R (PNo_bd L R) (PNo_pred L R).

Axiom PNo_bd_ord : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> ordinal (PNo_bd L R).

Axiom PNo_bd_pred_strict_imv : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_strict_imv L R (PNo_bd L R) (PNo_pred L R).

Axiom PNo_bd_least_imv : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> forall gamma :e PNo_bd L R,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.

Axiom PNo_bd_In : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_bd L R :e ordsucc alpha.

Definition PNoCutL : set -> (set -> prop) -> set -> (set -> prop) -> prop
  := fun alpha p beta q => beta :e alpha /\ PNoLt beta q alpha p.
Definition PNoCutR : set -> (set -> prop) -> set -> (set -> prop) -> prop
  := fun alpha p beta q => beta :e alpha /\ PNoLt alpha p beta q.

Axiom PNoCutL_lenbdd : forall alpha, forall p:set -> prop, PNo_lenbdd alpha (PNoCutL alpha p).

Axiom PNoCutR_lenbdd : forall alpha, forall p:set -> prop, PNo_lenbdd alpha (PNoCutR alpha p).

Axiom PNoCut_pwise : forall alpha, ordinal alpha -> forall p:set -> prop, PNoLt_pwise (PNoCutL alpha p) (PNoCutR alpha p).

Axiom PNoCut_strict_imv : forall alpha, ordinal alpha -> forall p:set -> prop, PNo_strict_imv (PNoCutL alpha p) (PNoCutR alpha p) alpha p.

Axiom PNoCut_bd_eq : forall alpha, ordinal alpha -> forall p:set -> prop, PNo_bd (PNoCutL alpha p) (PNoCutR alpha p) = alpha.

Axiom PNoCut_pred_eq : forall alpha, ordinal alpha -> forall p:set -> prop, PNoEq_ alpha p (PNo_pred (PNoCutL alpha p) (PNoCutR alpha p)).

Section TaggedSets.

Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Axiom not_TransSet_Sing1 : ~TransSet {1}.

Axiom not_ordinal_Sing1 : ~ordinal {1}.

Axiom tagged_not_ordinal : forall y, ~ordinal (y ').

Axiom tagged_notin_ordinal : forall alpha y, ordinal alpha -> (y ') /:e alpha.

Axiom tagged_eqE_Subq : forall alpha beta, ordinal alpha -> alpha ' = beta ' -> alpha c= beta.

Axiom tagged_eqE_eq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha ' = beta ' -> alpha = beta.

Axiom tagged_ReplE : forall alpha beta, ordinal alpha -> ordinal beta -> beta ' :e {gamma '|gamma :e alpha} -> beta :e alpha.

Axiom ordinal_notin_tagged_Repl : forall alpha Y, ordinal alpha -> alpha /:e {y '|y :e Y}.

Definition SNoElts_ : set -> set := fun alpha => alpha :\/: {beta '|beta :e alpha}.

Axiom SNoElts_mon : forall alpha beta, alpha c= beta -> SNoElts_ alpha c= SNoElts_ beta.

Definition SNo_ : set -> set -> prop := fun alpha x =>
    x c= SNoElts_ alpha
 /\ forall beta :e alpha, exactly1of2 (beta ' :e x) (beta :e x).

Definition PSNo : set -> (set -> prop) -> set :=
  fun alpha p => {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.

Axiom PNoEq_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, PNoEq_ alpha (fun beta => beta :e PSNo alpha p) p.

Axiom SNo_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNo_ alpha (PSNo alpha p).

Axiom SNo_PSNo_eta_ : forall alpha x, ordinal alpha -> SNo_ alpha x -> x = PSNo alpha (fun beta => beta :e x).

Definition SNo : set -> prop := fun x => exists alpha, ordinal alpha /\ SNo_ alpha x.

Axiom SNo_SNo : forall alpha, ordinal alpha -> forall z, SNo_ alpha z -> SNo z.

Definition SNoLev : set -> set := fun x => the (fun alpha => ordinal alpha /\ SNo_ alpha x).

Axiom SNoLev_uniq_Subq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha c= beta.

Axiom SNoLev_uniq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha = beta.

Axiom SNoLev_prop : forall x, SNo x -> ordinal (SNoLev x) /\ SNo_ (SNoLev x) x.

Axiom SNoLev_ordinal : forall x, SNo x -> ordinal (SNoLev x).

Axiom SNoLev_ : forall x, SNo x -> SNo_ (SNoLev x) x.

Axiom SNo_PSNo_eta : forall x, SNo x -> x = PSNo (SNoLev x) (fun beta => beta :e x).

Axiom SNoLev_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNoLev (PSNo alpha p) = alpha.

Axiom SNo_Subq : forall x y, SNo x -> SNo y -> SNoLev x c= SNoLev y -> (forall alpha :e SNoLev x, alpha :e x <-> alpha :e y) -> x c= y.

Definition SNoEq_ : set -> set -> set -> prop
 := fun alpha x y => PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).

Axiom SNoEq_I : forall alpha x y, (forall beta :e alpha, beta :e x <-> beta :e y) -> SNoEq_ alpha x y.

Axiom SNoEq_E : forall alpha x y, SNoEq_ alpha x y -> forall beta :e alpha, beta :e x <-> beta :e y.

Axiom SNoEq_E1 : forall alpha x y, SNoEq_ alpha x y -> forall beta :e alpha, beta :e x -> beta :e y.

Axiom SNoEq_E2 : forall alpha x y, SNoEq_ alpha x y -> forall beta :e alpha, beta :e y -> beta :e x.

Axiom SNoEq_antimon_ : forall alpha, ordinal alpha -> forall beta :e alpha, forall x y, SNoEq_ alpha x y -> SNoEq_ beta x y.

Axiom SNo_eq : forall x y, SNo x -> SNo y -> SNoLev x = SNoLev y -> SNoEq_ (SNoLev x) x y -> x = y.

Let ctag : set -> set := fun alpha => SetAdjoin alpha {2}.

Postfix '' 100 := ctag.

Axiom ctagged_not_ordinal : forall y, ~ordinal (y '').
Axiom ctagged_notin_ordinal : forall alpha y, ordinal alpha -> (y '') /:e alpha.
Axiom Sing2_notin_SingSing1 : {2} /:e {{1}}.

Axiom ctagged_notin_SNo : forall x y, SNo x -> (y '') /:e x.
Axiom ctagged_eqE_eq : forall x y, SNo x -> SNo y -> forall u :e x, forall v :e y, u '' = v '' -> u = v.

Definition SNo_pair : set -> set -> set := fun x y => x :\/: {u ''| u :e y}.

Axiom SNo_pair_prop_1 : forall x1 y1 x2 y2, SNo x1 -> SNo x2 -> SNo_pair x1 y1 = SNo_pair x2 y2 -> x1 = x2.
Axiom SNo_pair_prop_2 : forall x1 y1 x2 y2, SNo x1 -> SNo y1 -> SNo x2 -> SNo y2 -> SNo_pair x1 y1 = SNo_pair x2 y2 -> y1 = y2.
Axiom SNo_pair_prop : forall x1 y1 x2 y2, SNo x1 -> SNo y1 -> SNo x2 -> SNo y2 -> SNo_pair x1 y1 = SNo_pair x2 y2 -> x1 = x2 /\ y1 = y2.
Axiom SNo_pair_0 : forall x, SNo_pair x 0 = x.

End TaggedSets.

Definition SNoLt : set -> set -> prop :=
  fun x y => PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).

Infix < 490 := SNoLt.

Definition SNoLe : set -> set -> prop :=
  fun x y => PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).

(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Axiom SNoLtLe : forall x y, x < y -> x <= y.

Axiom SNoLeE : forall x y, SNo x -> SNo y -> x <= y -> x < y \/ x = y.

Axiom SNoEq_ref_ : forall alpha x, SNoEq_ alpha x x.

Axiom SNoEq_sym_ : forall alpha x y, SNoEq_ alpha x y -> SNoEq_ alpha y x.

Axiom SNoEq_tra_ : forall alpha x y z, SNoEq_ alpha x y -> SNoEq_ alpha y z -> SNoEq_ alpha x z.

Axiom SNoLtE : forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z, SNo z -> SNoLev z :e SNoLev x :/\: SNoLev y -> SNoEq_ (SNoLev z) z x -> SNoEq_ (SNoLev z) z y -> x < z -> z < y -> SNoLev z /:e x -> SNoLev z :e y -> p)
 -> (SNoLev x :e SNoLev y -> SNoEq_ (SNoLev x) x y -> SNoLev x :e y -> p)
 -> (SNoLev y :e SNoLev x -> SNoEq_ (SNoLev y) x y -> SNoLev y /:e x -> p)
 -> p.

(** The analogous theorem to PNoLtI1 can be recovered by SNoLt_tra (transitivity) and SNoLtI2 and SNoLtI3. **)

Axiom SNoLtI2 : forall x y,
     SNoLev x :e SNoLev y
  -> SNoEq_ (SNoLev x) x y
  -> SNoLev x :e y
  -> x < y.

Axiom SNoLtI3 : forall x y,
     SNoLev y :e SNoLev x
  -> SNoEq_ (SNoLev y) x y
  -> SNoLev y /:e x
  -> x < y.

Axiom SNoLt_irref : forall x, ~SNoLt x x.

Axiom SNoLt_trichotomy_or : forall x y, SNo x -> SNo y -> x < y \/ x = y \/ y < x.
Axiom SNoLt_trichotomy_or_impred : forall x y, SNo x -> SNo y ->
  forall p:prop,
      (x < y -> p)
   -> (x = y -> p)
   -> (y < x -> p)
   -> p.

Axiom SNoLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y < z -> x < z.

Axiom SNoLe_ref : forall x, SNoLe x x.

Axiom SNoLe_antisym : forall x y, SNo x -> SNo y -> x <= y -> y <= x -> x = y.

Axiom SNoLtLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y <= z -> x < z.

Axiom SNoLeLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y < z -> x < z.

Axiom SNoLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y <= z -> x <= z.

Axiom SNoLtLe_or : forall x y, SNo x -> SNo y -> x < y \/ y <= x.

Axiom SNoLt_PSNo_PNoLt : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PSNo alpha p < PSNo beta q -> PNoLt alpha p beta q.

Axiom PNoLt_SNoLt_PSNo : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q -> PSNo alpha p < PSNo beta q.

Definition SNoCut : set -> set -> set :=
  fun L R => PSNo (PNo_bd (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)) (PNo_pred (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)).

Definition SNoCutP : set -> set -> prop :=
 fun L R =>
      (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).

Axiom SNoCutP_SNoCut : forall L R, SNoCutP L R
 -> SNo (SNoCut L R)
 /\ SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
 /\ (forall x :e L, x < SNoCut L R)
 /\ (forall y :e R, SNoCut L R < y)
 /\ (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z).

Axiom SNoCutP_SNoCut_impred : forall L R, SNoCutP L R
 -> forall p:prop,
      (SNo (SNoCut L R)
    -> SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
    -> (forall x :e L, x < SNoCut L R)
    -> (forall y :e R, SNoCut L R < y)
    -> (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z)
    -> p)
   -> p.

Axiom ordinal_SNoLt_In : forall alpha beta, ordinal alpha -> ordinal beta -> alpha < beta -> alpha :e beta.

Axiom ordinal_SNoLe_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha <= beta -> alpha c= beta.

Definition SNoS_ : set -> set := fun alpha => {x :e Power (SNoElts_ alpha)|exists beta :e alpha, SNo_ beta x}.

Axiom SNoS_E : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, exists beta :e alpha, SNo_ beta x.

Section TaggedSets2.

Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Axiom SNoS_I : forall alpha, ordinal alpha -> forall x, forall beta :e alpha, SNo_ beta x -> x :e SNoS_ alpha.

Axiom SNoS_I2 : forall x y, SNo x -> SNo y -> SNoLev x :e SNoLev y -> x :e SNoS_ (SNoLev y).
 
Axiom SNoS_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> SNoS_ alpha c= SNoS_ beta.

Axiom SNoLev_uniq2 : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNoLev x = alpha.

Axiom SNoS_E2 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha,
 forall p:prop,
     (SNoLev x :e alpha -> ordinal (SNoLev x) -> SNo x -> SNo_ (SNoLev x) x -> p)
  -> p.

Axiom SNoS_In_neq : forall w, SNo w -> forall x :e SNoS_ (SNoLev w), x <> w.

Axiom SNoS_SNoLev : forall z, SNo z -> z :e SNoS_ (ordsucc (SNoLev z)).

Definition SNoL : set -> set := fun z => {x :e SNoS_ (SNoLev z) | x < z}.
Definition SNoR : set -> set := fun z => {y :e SNoS_ (SNoLev z) | z < y}.

Axiom SNoCutP_SNoL_SNoR: forall z, SNo z -> SNoCutP (SNoL z) (SNoR z).

Axiom SNoL_E : forall x, SNo x -> forall w :e SNoL x,
  forall p:prop,
       (SNo w -> SNoLev w :e SNoLev x -> w < x -> p)
    -> p.

Axiom SNoR_E : forall x, SNo x -> forall z :e SNoR x,
  forall p:prop,
       (SNo z -> SNoLev z :e SNoLev x -> x < z -> p)
    -> p.

Axiom SNoL_SNoS : forall x, SNo x -> forall w :e SNoL x, w :e SNoS_ (SNoLev x).
Axiom SNoR_SNoS : forall x, SNo x -> forall z :e SNoR x, z :e SNoS_ (SNoLev x).
Axiom SNoL_SNoS_ : forall z, SNoL z c= SNoS_ (SNoLev z).
Axiom SNoR_SNoS_ : forall z, SNoR z c= SNoS_ (SNoLev z).

Axiom SNoL_I : forall z, SNo z -> forall x, SNo x -> SNoLev x :e SNoLev z -> x < z -> x :e SNoL z.

Axiom SNoR_I : forall z, SNo z -> forall y, SNo y -> SNoLev y :e SNoLev z -> z < y -> y :e SNoR z.

Axiom SNo_eta : forall z, SNo z -> z = SNoCut (SNoL z) (SNoR z).

Axiom SNoCutP_SNo_SNoCut : forall L R, SNoCutP L R -> SNo (SNoCut L R).

Axiom SNoCutP_SNoCut_L : forall L R, SNoCutP L R -> forall x :e L, x < SNoCut L R.

Axiom SNoCutP_SNoCut_R : forall L R, SNoCutP L R -> forall y :e R, SNoCut L R < y.

Axiom SNoCutP_SNoCut_fst : forall L R, SNoCutP L R ->
 forall z, SNo z
   -> (forall x :e L, x < z)
   -> (forall y :e R, z < y)
   -> SNoLev (SNoCut L R) c= SNoLev z
   /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z.

Axiom SNoCut_Le : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 <= SNoCut L2 R2.

Axiom SNoCut_ext : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R1, SNoCut L2 R2 < z)
  -> (forall w :e L2, w < SNoCut L1 R1)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 = SNoCut L2 R2.

Axiom ordinal_SNo_ : forall alpha, ordinal alpha -> SNo_ alpha alpha.

Axiom ordinal_SNoL : forall alpha, ordinal alpha -> SNoL alpha = SNoS_ alpha.
Axiom ordinal_SNoR : forall alpha, ordinal alpha -> SNoR alpha = Empty.
Axiom ordinal_SNoCutP : forall alpha, ordinal alpha -> SNoCutP (SNoS_ alpha) Empty.
Axiom ordinal_SNoCut_eta : forall alpha, ordinal alpha -> alpha = SNoCut (SNoS_ alpha) Empty.

Axiom SNo_0 : SNo 0.
Axiom SNoLev_0 : SNoLev 0 = 0.
Axiom SNoL_0 : SNoL 0 = 0.
Axiom SNoR_0 : SNoR 0 = 0.
Axiom SNo_max_SNoLev : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> SNoLev x = x.
Axiom SNo_max_ordinal : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> ordinal x.

Definition SNo_extend0 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x /\ delta <> SNoLev x).

Definition SNo_extend1 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x \/ delta = SNoLev x).

Axiom SNo_extend0_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend0 x).

Axiom SNo_extend1_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend1 x).

Axiom SNo_extend0_SNo : forall x, SNo x -> SNo (SNo_extend0 x).

Axiom SNo_extend1_SNo : forall x, SNo x -> SNo (SNo_extend1 x).

Axiom SNo_extend0_SNoLev : forall x, SNo x -> SNoLev (SNo_extend0 x) = ordsucc (SNoLev x).

Axiom SNo_extend1_SNoLev : forall x, SNo x -> SNoLev (SNo_extend1 x) = ordsucc (SNoLev x).

Axiom SNo_extend0_nIn : forall x, SNo x -> SNoLev x /:e SNo_extend0 x.

Axiom SNo_extend1_In : forall x, SNo x -> SNoLev x :e SNo_extend1 x.

Axiom SNo_extend0_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend0 x) x.

Axiom SNo_extend1_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend1 x) x.

Axiom SNo_extend0_Lt: forall x, SNo x -> SNo_extend0 x < x.
Axiom SNo_extend1_Gt: forall x, SNo x -> x < SNo_extend1 x.

End TaggedSets2.

Axiom ordinal_SNo : forall alpha, ordinal alpha -> SNo alpha.

Axiom ordinal_SNoLev : forall alpha, ordinal alpha -> SNoLev alpha = alpha.

Axiom ordinal_SNoLev_max : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> z < alpha.

Axiom ordinal_In_SNoLt : forall alpha, ordinal alpha -> forall beta :e alpha, beta < alpha.

Axiom ordinal_SNoLev_max_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> z <= alpha.

Axiom ordinal_Subq_SNoLe : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> alpha <= beta.

Axiom SNo_etaE : forall z, SNo z ->
  forall p:prop,
     (forall L R, SNoCutP L R
       -> (forall x :e L, SNoLev x :e SNoLev z)
       -> (forall y :e R, SNoLev y :e SNoLev z)
       -> z = SNoCut L R
       -> p)
   -> p.

(*** surreal induction ***)
Axiom SNo_ind : forall P:set -> prop,
  (forall L R, SNoCutP L R
   -> (forall x :e L, P x)
   -> (forall y :e R, P y)
   -> P (SNoCut L R))
 -> forall z, SNo z -> P z.


(*** surreal recursion ***)
Section SurrealRecI.

Variable F:set -> (set -> set) -> set.

(* Parameter SNo_rec_i "6ef383d5a7cb35543ea97d8dc82d7a31042cc5b5c46d5b7b595e4698bd595edd" "9f8e2304576ffa952352f8f3f610451b610851d503c2e48227e360bb64fc68bc" *)
Parameter SNo_rec_i : set -> set.

Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> set, (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Axiom SNo_rec_i_eq : forall z, SNo z -> SNo_rec_i z = F z SNo_rec_i.

End SurrealRecI.

Section SurrealRecII.

Variable F:set -> (set -> (set -> set)) -> (set -> set).

(* Parameter SNo_rec_ii "621bdb08871e5a330c5df471c8ce7da9e0c8c5afca5ef3a2bd60ecaca464b79f" "b16faf0c45cf3946fd4a4c3f8c4fe03418754014fdbb1414b973af0d92860f39" *)
Parameter SNo_rec_ii : set -> (set -> set).

Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> (set -> set), (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Axiom SNo_rec_ii_eq : forall z, SNo z -> SNo_rec_ii z = F z SNo_rec_ii.

End SurrealRecII.

Section SurrealRec2.

Variable F:set -> set -> (set -> set -> set) -> set.

(* Parameter SNo_rec2 "5adf8716eaff9e6c8321bcafd1a9b899940159053310f63d7d7e91d3b47e773c" "3e27ae253bcfddd2ba941567a179946e315ab41cdb5f3744d355ad35c3f2f7dc" *)
Parameter SNo_rec2 : set -> set -> set.

Hypothesis Fr: forall w, SNo w -> forall z, SNo z ->
   forall g h:set -> set -> set,
        (forall x :e SNoS_ (SNoLev w), forall y, SNo y -> g x y = h x y)
     -> (forall y :e SNoS_ (SNoLev z), g w y = h w y)
     -> F w z g = F w z h.

Axiom SNo_rec2_eq : forall w, SNo w -> forall z, SNo z ->
   SNo_rec2 w z = F w z SNo_rec2.

End SurrealRec2.

Axiom SNo_ordinal_ind : forall P:set -> prop,
  (forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, P x)
  ->
  (forall x, SNo x -> P x).

Axiom SNo_ordinal_ind2 : forall P:set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, P x y)
  ->
  (forall x y, SNo x -> SNo y -> P x y).

Axiom SNo_ordinal_ind3 : forall P:set -> set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall gamma, ordinal gamma ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z)
  ->
  (forall x y z, SNo x -> SNo y -> SNo z -> P x y z).

Axiom SNoLev_ind : forall P:set -> prop,
  (forall x, SNo x -> (forall w :e SNoS_ (SNoLev x), P w) -> P x)
  ->
  (forall x, SNo x -> P x).

Axiom SNoLev_ind2 : forall P:set -> set -> prop,
  (forall x y, SNo x -> SNo y
    -> (forall w :e SNoS_ (SNoLev x), P w y)
    -> (forall z :e SNoS_ (SNoLev y), P x z)
    -> (forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z)
    -> P x y)
-> forall x y, SNo x -> SNo y -> P x y.

Axiom SNoLev_ind3 : forall P:set -> set -> set -> prop,
  (forall x y z, SNo x -> SNo y -> SNo z
    -> (forall u :e SNoS_ (SNoLev x), P u y z)
    -> (forall v :e SNoS_ (SNoLev y), P x v z)
    -> (forall w :e SNoS_ (SNoLev z), P x y w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z)
    -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w)
    -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w)
    -> P x y z)
 -> forall x y z, SNo x -> SNo y -> SNo z -> P x y z.

Axiom SNo_1 : SNo 1.
Axiom SNo_2 : SNo 2.
Axiom SNo_omega : SNo omega.
Axiom SNoLt_0_1 : 0 < 1.
Axiom SNoLt_0_2 : 0 < 2.
Axiom SNoLt_1_2 : 1 < 2.

(* Parameter pack_e "81bff9e86e9cf23d200aa5d2dd18b7ce6d2c0f1c3189f4f3aaead447314d80dc" "63811d0661e154a6daf3eb792d9cdbf11bc4225ddc822a694e28c016c983e90d" *)
Parameter pack_e : set -> set -> set.

Axiom pack_e_0_eq : forall S X, forall c:set, S = pack_e X c -> X = S 0.

Axiom pack_e_0_eq2 : forall X, forall c:set, X = pack_e X c 0.

Axiom pack_e_1_eq : forall S X, forall c:set, S = pack_e X c -> c = S 1.

Axiom pack_e_1_eq2 : forall X, forall c:set, c = pack_e X c 1.

Axiom pack_e_inj: forall X X', forall c c', pack_e X c = pack_e X' c' -> X = X' /\ c = c'.

Definition struct_e : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall c:set, c :e X -> q (pack_e X c)) -> q S.

Axiom pack_struct_e_I: forall X, forall c:set, c :e X -> struct_e (pack_e X c).

Axiom pack_struct_e_E1: forall X, forall c:set, struct_e (pack_e X c) -> c :e X.

Axiom struct_e_eta: forall S, struct_e S -> S = pack_e (S 0) (S 1).

(* Parameter unpack_e_i "32918f9589cd95495375a45cd1a0126dc0816663aeb01184c87abd2395d42f70" "93bb613be8f7458630d22d7ce010bec4de94ef0dcf36f06bd009df8de2141951" *)
Parameter unpack_e_i : set -> (set -> set -> set) -> set.

Axiom unpack_e_i_eq : forall Phi:set -> set -> set,
  forall X, forall c:set, unpack_e_i (pack_e X c) Phi = Phi X c.

(* Parameter unpack_e_o "d64b764ad19ac93ecb12cd580ba5fa0dd123d9f616850a510f59a45d7a0e0452" "1df85a579156ff9ba47de7c3cf0227b4785fe705f50088cb6733ed8f54c507ac" *)
Parameter unpack_e_o : set -> (set -> set -> prop) -> prop.

Axiom unpack_e_o_eq : forall Phi:set -> set -> prop,
  forall X, forall c:set, unpack_e_o (pack_e X c) Phi = Phi X c.

(* Parameter pack_u "864b625dd5e1221afa0f442857187dc1f0f89c20e305c1d0393c247694208203" "835364c9ab274baa12a3b6cb6cf61879c0f31ec7fc235b6d41f4620183860d39" *)
Parameter pack_u : set -> (set -> set) -> set.

Axiom pack_u_0_eq : forall S X, forall F:set -> set, S = pack_u X F -> X = S 0.

Axiom pack_u_0_eq2 : forall X, forall F:set -> set, X = pack_u X F 0.

Axiom pack_u_1_eq : forall S X, forall F:set -> set, S = pack_u X F -> forall x :e X, F x = decode_u (S 1) x.

Axiom pack_u_1_eq2 : forall X, forall F:set -> set, forall x :e X, F x = decode_u (pack_u X F 1) x.

Axiom pack_u_inj: forall X X', forall F F':set -> set, pack_u X F = pack_u X' F' -> X = X' /\ forall x :e X, F x = F' x.

Axiom pack_u_ext : forall X, forall F F':set -> set,
     (forall x :e X, F x = F' x)
  -> pack_u X F = pack_u X F'.

Definition struct_u : set -> prop := fun S => forall q:set -> prop, (forall X, forall F:set -> set, (forall x :e X, F x :e X) -> q (pack_u X F)) -> q S.

Axiom pack_struct_u_I: forall X, forall F:set -> set, (forall x :e X, F x :e X) -> struct_u (pack_u X F).

Axiom pack_struct_u_E1: forall X, forall F:set -> set, struct_u (pack_u X F) -> forall x :e X, F x :e X.

Axiom struct_u_eta: forall S, struct_u S -> S = pack_u (S 0) (decode_u (S 1)).

(* Parameter unpack_u_i "e7ea477592868d1906eb956978d7782b15cac5385f54a9b0be37fcf7c1dbed7e" "232533d7371d9e02b27d053dc55c000d5a7f62a930c0aba335d54cc23b5000da" *)
Parameter unpack_u_i : set -> (set -> (set -> set) -> set) -> set.

Axiom unpack_u_i_eq : forall Phi:set -> (set -> set) -> set,
  forall X, forall F:set -> set,
  (forall F':set -> set, (forall x :e X, F x = F' x) -> Phi X F' = Phi X F)
  ->
  unpack_u_i (pack_u X F) Phi = Phi X F.

(* Parameter unpack_u_o "21f987cc4b6725533cb934ec669325061fa0dc49828307825a3fa475b9e11f7d" "fa072ab279b1dc4170e0608971752690a8df647c442441ca1e6307d0df7fb2f3" *)
Parameter unpack_u_o : set -> (set -> (set -> set) -> prop) -> prop.

Axiom unpack_u_o_eq : forall Phi:set -> (set -> set) -> prop,
  forall X, forall F:set -> set,
  (forall F':set -> set, (forall x :e X, F x = F' x) -> Phi X F' = Phi X F)
  ->
  unpack_u_o (pack_u X F) Phi = Phi X F.

(* Parameter pack_b "51ae9a7f5f4dcff068cb2634562b52abc695fafd17015732a82b13afe460251d" "7134839602ccd8452b12ba4ab2a48007628cad6ab4fe4453ae9f309b57cd68c6" *)
Parameter pack_b : set -> (set -> set -> set) -> set.

Axiom pack_b_0_eq : forall S X, forall F:set -> set -> set, S = pack_b X F -> X = S 0.

Axiom pack_b_0_eq2 : forall X, forall F:set -> set -> set, X = pack_b X F 0.

Axiom pack_b_1_eq : forall S X, forall F:set -> set -> set, S = pack_b X F -> forall x y :e X, F x y = decode_b (S 1) x y.

Axiom pack_b_1_eq2 : forall X, forall F:set -> set -> set, forall x y :e X, F x y = decode_b (pack_b X F 1) x y.

Axiom pack_b_inj: forall X X', forall F F':set -> set -> set, pack_b X F = pack_b X' F' -> X = X' /\ forall x y :e X, F x y = F' x y.

Axiom pack_b_ext : forall X, forall F F':set -> set -> set,
     (forall x y :e X, F x y = F' x y)
  -> pack_b X F = pack_b X F'.

Definition struct_b : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall F:set -> set -> set, (forall x y :e X, F x y :e X) -> q (pack_b X F)) -> q S.

Axiom pack_struct_b_I: forall X, forall F:set -> set -> set, (forall x y :e X, F x y :e X) -> struct_b (pack_b X F).

Axiom pack_struct_b_E1: forall X, forall F:set -> set -> set, struct_b (pack_b X F) -> forall x y :e X, F x y :e X.

Axiom struct_b_eta: forall S, struct_b S -> S = pack_b (S 0) (decode_b (S 1)).

(* Parameter unpack_b_i "578102c1363550de89ff1c61cb3c5b8c936495697c5f285e6053341f4a782993" "9e4ea949ca381a31d3d524337c47bbb18eaba1fee47c103c098af1b597f5237d" *)
Parameter unpack_b_i : set -> (set -> (set -> set -> set) -> set) -> set.

Axiom unpack_b_i_eq : forall Phi:set -> (set -> set -> set) -> set,
  forall X, forall F:set -> set -> set,
  (forall F':set -> set -> set, (forall x y :e X, F x y = F' x y) -> Phi X F' = Phi X F)
  ->
  unpack_b_i (pack_b X F) Phi = Phi X F.

(* Parameter unpack_b_o "cf16b0122a9be531c7846cd4d6b77594cdb22a2fbbcf066bbf14296994c5ef2b" "6e1a8512af9667f8321dd6aeed713eb7cd1d3c51ad029d34f7b1a0b7f2d70b9b" *)
Parameter unpack_b_o : set -> (set -> (set -> set -> set) -> prop) -> prop.

Axiom unpack_b_o_eq : forall Phi:set -> (set -> set -> set) -> prop,
  forall X, forall F:set -> set -> set,
  (forall F':set -> set -> set, (forall x y :e X, F x y = F' x y) -> Phi X F' = Phi X F)
  ->
  unpack_b_o (pack_b X F) Phi = Phi X F.

(* Parameter pack_p "9d4d182c3f14abfbb6b1a3d8ff8363585088b756aa9ca252fe66e02383087dbc" "4cbdd9d90476edead054ddeffe6997bd586cc14542f24ae2805949481bd6c253" *)
Parameter pack_p : set -> (set -> prop) -> set.

Axiom pack_p_0_eq : forall S X, forall P:set -> prop, S = pack_p X P -> X = S 0.

Axiom pack_p_0_eq2 : forall X, forall P:set -> prop, X = pack_p X P 0.

Axiom pack_p_1_eq : forall S X, forall P:set -> prop, S = pack_p X P -> forall x :e X, P x = decode_p (S 1) x.

Axiom pack_p_1_eq2 : forall X, forall P:set -> prop, forall x :e X, P x = decode_p (pack_p X P 1) x.

Axiom pack_p_inj: forall X X', forall P P':set -> prop, pack_p X P = pack_p X' P' -> X = X' /\ forall x :e X, P x = P' x.

Axiom pack_p_ext : forall X, forall P P':set -> prop,
     (forall x :e X, P x <-> P' x)
  -> pack_p X P = pack_p X P'.

Definition struct_p : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall P:set -> prop, q (pack_p X P)) -> q S.

Axiom pack_struct_p_I: forall X, forall P:set -> prop, struct_p (pack_p X P).

Axiom struct_p_eta: forall S, struct_p S -> S = pack_p (S 0) (decode_p (S 1)).

(* Parameter unpack_p_i "556cb9bacb99f8a0e27bb5c3b331b7e1741388ec87fd081d5b37c894995197f1" "37fa547858a119ebea7984749826e8b0269b3d65db4d6df47dc0475bac595314" *)
Parameter unpack_p_i : set -> (set -> (set -> prop) -> set) -> set.

Axiom unpack_p_i_eq : forall Phi:set -> (set -> prop) -> set,
  forall X, forall P:set -> prop,
  (forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X P' = Phi X P)
  ->
  unpack_p_i (pack_p X P) Phi = Phi X P.

(* Parameter unpack_p_o "a714fa9fb6b2a1c888b7bd6c477c3640cc07b82537ffa1e6ee1030f33201b4eb" "bdc98970df3c7049444bd041342f501f891b5e58f74ba9600bd03eb97236c9c1" *)
Parameter unpack_p_o : set -> (set -> (set -> prop) -> prop) -> prop.

Axiom unpack_p_o_eq : forall Phi:set -> (set -> prop) -> prop,
  forall X, forall P:set -> prop,
  (forall P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X P' = Phi X P)
  ->
  unpack_p_o (pack_p X P) Phi = Phi X P.

(* Parameter pack_r "80f050c82feadd1be16bfbc3da8d4ea2cc65349552892806687e04b05b861f0e" "f4216dc6d92f9860c62894e04a779cae700c98318e49cddd6b7e059f25f87bcc" *)
Parameter pack_r : set -> (set -> set -> prop) -> set.

Axiom pack_r_0_eq : forall S X, forall R:set -> set -> prop, S = pack_r X R -> X = S 0.

Axiom pack_r_0_eq2 : forall X, forall R:set -> set -> prop, X = pack_r X R 0.

Axiom pack_r_1_eq : forall S X, forall R:set -> set -> prop, S = pack_r X R -> forall x y :e X, R x y = decode_r (S 1) x y.

Axiom pack_r_1_eq2 : forall X, forall R:set -> set -> prop, forall x y :e X, R x y = decode_r (pack_r X R 1) x y.

Axiom pack_r_inj: forall X X', forall R R':set -> set -> prop, pack_r X R = pack_r X' R' -> X = X' /\ forall x y :e X, R x y = R' x y.

Axiom pack_r_ext : forall X, forall R R':set -> set -> prop,
     (forall x y :e X, R x y <-> R' x y)
  -> pack_r X R = pack_r X R'.

Definition struct_r : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall R:set -> set -> prop, q (pack_r X R)) -> q S.

Axiom pack_struct_r_I: forall X, forall R:set -> set -> prop, struct_r (pack_r X R).

Axiom struct_r_eta: forall S, struct_r S -> S = pack_r (S 0) (decode_r (S 1)).

(* Parameter unpack_r_i "14d10b881f4c23f85978f5b31625c2f22ec76bd18abcb62a5cd29d5ae3ace598" "dac7d5b3199f1cbee92a94cb41bff9252294986ebb12e92233b37daedf29ee3e" *)
Parameter unpack_r_i : set -> (set -> (set -> set -> prop) -> set) -> set.

Axiom unpack_r_i_eq : forall Phi:set -> (set -> set -> prop) -> set,
  forall X, forall R:set -> set -> prop,
  (forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X R' = Phi X R)
  ->
  unpack_r_i (pack_r X R) Phi = Phi X R.

(* Parameter unpack_r_o "92919cdeb9315ce58115e6dac3239b1db2fc46c5878c30776444856213838d56" "8548860a31cd8b6363e4bb37d3f7c6505b4e65717f3035e3b5c405e43dc90202" *)
Parameter unpack_r_o : set -> (set -> (set -> set -> prop) -> prop) -> prop.

Axiom unpack_r_o_eq : forall Phi:set -> (set -> set -> prop) -> prop,
  forall X, forall R:set -> set -> prop,
  (forall R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X R' = Phi X R)
  ->
  unpack_r_o (pack_r X R) Phi = Phi X R.

(* Parameter pack_c "56ea1298314bc2fa1c196fcf83840e8ceaa6fb4d2b5a4005c445ac3d49c8897d" "4c3dd74889c6e37a9756bf800c54c195249b26a24e117ba9a3e373147494f066" *)
Parameter pack_c : set -> ((set -> prop) -> prop) -> set.

Axiom pack_c_0_eq : forall S X, forall C:(set -> prop) -> prop, S = pack_c X C -> X = S 0.

Axiom pack_c_0_eq2 : forall X, forall C:(set -> prop) -> prop, X = pack_c X C 0.

Axiom pack_c_1_eq : forall S X, forall C:(set -> prop) -> prop, S = pack_c X C -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.

Axiom pack_c_1_eq2 : forall X, forall C:(set -> prop) -> prop, forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (pack_c X C 1) U.

Axiom pack_c_inj: forall X X', forall C C':(set -> prop) -> prop, pack_c X C = pack_c X' C' -> X = X' /\ forall U:set -> prop, (forall x, U x -> x :e X) -> C U = C' U.

Axiom pack_c_ext : forall X, forall C C':(set -> prop) -> prop,
     (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U))
  -> pack_c X C = pack_c X C'.

Definition struct_c : set -> prop := fun S => forall q:set -> prop, (forall X:set, forall C:(set -> prop) -> prop, q (pack_c X C)) -> q S.

Axiom pack_struct_c_I: forall X, forall C:(set -> prop) -> prop, struct_c (pack_c X C).

Axiom struct_c_eta: forall S, struct_c S -> S = pack_c (S 0) (decode_c (S 1)).

(* Parameter unpack_c_i "72e48f0f2e2e0291bab12e6f2a9320686efc323232306eb261abec8d73af22a7" "98247350af7ebbb9715ce711493a4f466f3dda2c60512b6210007a6601c21d28" *)
Parameter unpack_c_i : set -> (set -> ((set -> prop) -> prop) -> set) -> set.

Axiom unpack_c_i_eq : forall Phi:set -> ((set -> prop) -> prop) -> set,
  forall X, forall C:(set -> prop) -> prop,
  (forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) -> Phi X C' = Phi X C)
  ->
  unpack_c_i (pack_c X C) Phi = Phi X C.

(* Parameter unpack_c_o "970f250aaca60a4686a01408e371ec6de7c390afc1fdf74d98085e55f40a6a87" "e96ab406d4039b5210f79a3c5a54ce76dc6e09cbc7731e7cd72e5c8918a7cb52" *)
Parameter unpack_c_o : set -> (set -> ((set -> prop) -> prop) -> prop) -> prop.

Axiom unpack_c_o_eq : forall Phi:set -> ((set -> prop) -> prop) -> prop,
  forall X, forall C:(set -> prop) -> prop,
  (forall C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) -> Phi X C' = Phi X C)
  ->
  unpack_c_o (pack_c X C) Phi = Phi X C.

(**
 Abstract Version of Natural Numbers using Peano axioms.
 Note that zero can be thought of as 0 or 1, with the difference
 only showing up if one defines addition and multiplication.
 **)
Section NatsP.

Variable N : set.
Variable zero : set.
Variable S : set -> set.

(* Parameter NatsP "4a59caa11140eabb1b7db2d3493fe76a92b002b3b27e3dfdd313708c6c6ca78f" "3fb62f75e778736947d086a36d35ebe45a5d60bf0a340a0761ba08a396d4123a" *)
Parameter NatsP : prop.

Axiom NatsP_I:
    (zero :e N)
 -> (forall m :e N, S m :e N)
 -> (forall m :e N, S m <> zero)
 -> (forall m n :e N, S m = S n -> m = n)
 -> (forall p:set -> prop, p zero -> (forall m, p m -> p (S m)) -> (forall m :e N, p m))
 -> NatsP.

Axiom NatsP_E : forall q:prop, 
    (NatsP
  -> (zero :e N)
  -> (forall m :e N, S m :e N)
  -> (forall m :e N, S m <> zero)
  -> (forall m n :e N, S m = S n -> m = n)
  -> (forall p:set -> prop, p zero -> (forall m, p m -> p (S m)) -> (forall m :e N, p m))
  -> q)
 -> NatsP -> q.

Axiom NatsP_ind : NatsP ->
  forall p:set -> prop,
      p zero
   -> (forall m :e N, p m -> p (S m))
   -> forall m :e N, p m.
  
End NatsP.

Axiom NatsP_omega : NatsP omega 0 ordsucc.

Section NatsP_transfer.

Variable N : set.
Variable zero : set.
Variable S : set -> set.
Variable N' : set.
Variable zero' : set.
Variable S' : set -> set.

Variable f:set -> set.

Axiom NatsP_transfer: NatsP N zero S -> bij N N' f -> f zero = zero' -> (forall n :e N, f (S n) = S' (f n)) -> NatsP N' zero' S'.

End NatsP_transfer.

(** Mostly Following Dieudonne's Foundations of Modern Analysis
    (first two pages of Chapter 2),
    except the zero and one elements are explicit to easily
    use them in multiple conditions.
 **)
Section RealsP.

Variable R : set.

Variable zero one : set.
Variable plus mult : set -> set -> set.

Infix + 360 right := plus.
Infix * 355 right := mult.

(* Parameter FieldP "b2707c82b8b416a22264d2934d5221d1115ea55732f96cbb6663fbf7e945d3e3" "32dcc27d27b5003a86f8b13ba9ca16ffaec7168a11c5d9850940847c48148591" *)
Parameter FieldP : prop.

Axiom FieldP_I : (forall x y :e R, x + y :e R)
 -> (forall x y z :e R, x + (y + z) = (x + y) + z)
 -> (forall x y :e R, x + y = y + x)
 -> zero :e R 
 -> (forall x :e R, zero + x = x)
 -> (forall x :e R, exists y :e R, x + y = zero)
 -> (forall x y :e R, x * y :e R)
 -> (forall x y z :e R, x * (y * z) = (x * y) * z)
 -> (forall x y :e R, x * y = y * x)
 -> (one :e R)
 -> (one <> zero)
 -> (forall x :e R, one * x = x)
 -> (forall x :e R, x <> zero -> exists y :e R, x * y = one)
 -> (forall x y z :e R, x * (y + z) = x * y + x * z)
 -> FieldP.

Axiom FieldP_E : forall q:prop,
    (FieldP
  -> (forall x y :e R, x + y :e R)
  -> (forall x y z :e R, x + (y + z) = (x + y) + z)
  -> (forall x y :e R, x + y = y + x)
  -> (zero :e R)
  -> (forall x :e R, zero + x = x)
  -> (forall x :e R, exists y :e R, x + y = zero)
  -> (forall x y :e R, x * y :e R)
  -> (forall x y z :e R, x * (y * z) = (x * y) * z)
  -> (forall x y :e R, x * y = y * x)
  -> (one :e R)
  -> (one <> zero)
  -> (forall x :e R, one * x = x)
  -> (forall x :e R, x <> zero -> exists y :e R, x * y = one)
  -> (forall x y z :e R, x * (y + z) = x * y + x * z)
  -> q)
 -> FieldP -> q.

(* Parameter FieldP_minus "be660f6f1e37e7325ec2a39529b9c937b61a60f864e85f0dabdf2bddacb0986e" "5be570b4bcbe7fefd36c2057491ddcc7b11903d8d98ca54d9b37db60d1bf0f7e" *)
Parameter FieldP_minus : set -> set.

Prefix - 358 := FieldP_minus.

Axiom FieldP_minus_prop : FieldP -> forall x :e R, - x :e R /\ x + - x = zero.
Axiom FieldP_minus_clos : FieldP -> forall x :e R, - x :e R.
Axiom FieldP_minus_R : FieldP -> forall x :e R, x + - x = zero.
Axiom FieldP_minus_L : FieldP -> forall x :e R, - x + x = zero.
Axiom FieldP_plus_cancelL : FieldP -> forall x y z :e R, x + y = x + z -> y = z.
Axiom FieldP_plus_cancelR : FieldP -> forall x y z :e R, x + z = y + z -> x = y.
Axiom FieldP_minus_invol : FieldP -> forall x :e R, - - x = x.
Axiom FieldP_minus_one_R : FieldP -> - one :e R.
Axiom FieldP_zero_multR : FieldP -> forall x :e R, x * zero = zero.
Axiom FieldP_zero_multL : FieldP -> forall x :e R, zero * x = zero.
Axiom FieldP_minus_mult : FieldP -> forall x :e R, - x = (- one) * x.
Axiom FieldP_minus_one_square : FieldP -> (- one) * (- one) = one.
Axiom FieldP_minus_square : FieldP -> forall x :e R, (- x) * (- x) = x * x.

Axiom FieldP_minus_zero : FieldP -> - zero = zero.
Axiom FieldP_dist_R : FieldP -> forall x y z :e R, (x + y) * z = x * z + y * z.
Axiom FieldP_minus_plus_dist : FieldP -> forall x y :e R, - (x + y) = - x + - y.
Axiom FieldP_minus_mult_L : FieldP -> forall x y :e R, (- x) * y = - (x * y).
Axiom FieldP_minus_mult_R : FieldP -> forall x y :e R, x * (- y) = - (x * y).
Axiom FieldP_square_zero_inv : FieldP -> forall x :e R, x * x = zero -> x = zero.

Variable leq : set -> set -> prop.

(* Unicode <= "2264" *)
Infix <= 490 := leq.

(* Parameter OrderedFieldP "1195f96dcd143e4b896b4c1eb080d1fb877084debc58a8626d3dcf7a14ce8df7" "a18f7bca989a67fb7dc6df8e6c094372c26fa2c334578447d3314616155afb72" *)
Parameter OrderedFieldP : prop.

Axiom OrderedFieldP_I : FieldP
 -> (forall x y z :e R, x <= y -> y <= z -> x <= z)
 -> (forall x y :e R, x <= y /\ y <= x <-> x = y)
 -> (forall x y :e R, x <= y \/ y <= x)
 -> (forall x y z :e R, x <= y -> x + z <= y + z)
 -> (forall x y :e R, zero <= x -> zero <= y -> zero <= x * y)
 -> OrderedFieldP.

Axiom OrderedFieldP_E : forall q:prop,
    (OrderedFieldP
  -> FieldP
  -> (forall x y z :e R, x <= y -> y <= z -> x <= z)
  -> (forall x y :e R, x <= y /\ y <= x <-> x = y)
  -> (forall x y :e R, x <= y \/ y <= x)
  -> (forall x y z :e R, x <= y -> x + z <= y + z)
  -> (forall x y :e R, zero <= x -> zero <= y -> zero <= x * y)
  -> q)
 -> OrderedFieldP -> q.

Axiom OrderedFieldP_minus_leq : OrderedFieldP -> forall x y :e R, x <= y -> - y <= - x.
Axiom OrderedFieldP_square_nonneg : OrderedFieldP -> forall x :e R, zero <= x * x.
Axiom OrderedFieldP_sum_squares_nonneg : OrderedFieldP -> forall x y :e R, zero <= x * x + y * y.
Axiom OrderedFieldP_sum_nonneg_zero_inv : OrderedFieldP -> forall x y :e R, zero <= x -> zero <= y -> x + y = zero -> x = zero /\ y = zero.
Axiom OrderedFieldP_sum_squares_zero_inv : OrderedFieldP -> forall x y :e R, x * x + y * y = zero -> x = zero /\ y = zero.

Definition lt : set -> set -> prop := fun x y => x <= y /\ x <> y.
Infix < 490 := lt.

(* Parameter natOfOrderedField_p "f97b150093ec13f84694e2b8f48becf45e4b6df2b43c1085ae7a99663116b9a6" "f1c45e0e9f9df75c62335865582f186c3ec3df1a94bc94b16d41e73bf27899f9" *)
Parameter natOfOrderedField_p : set -> prop.

Let N := {n :e R | natOfOrderedField_p n}.

Axiom NatsP_natOfOrderedField: OrderedFieldP -> NatsP N zero (fun m => m + one).

(* Parameter RealsP "82aa95de2af7a7c566e5ddc82fcb83d49c4c7c2ed89187c92e336c3336c4336e" "a479478ef1fc8bead93fc80b79a592119125d3b7b945ed09210d27d7822d23a4" *)
Parameter RealsP : prop.

Axiom RealsP_I : OrderedFieldP
 -> (forall x y :e R, zero < x -> zero <= y -> exists n :e N, y <= n * x)
 -> (forall a b :e R :^: N,
         (forall n :e N, a n <= b n /\ a n <= a (n + one) /\ b (n + one) <= b n)
      -> exists x :e R, forall n :e N, a n <= x /\ x <= b n)
 -> RealsP.

Axiom RealsP_E : forall q:prop,
    (RealsP
  -> OrderedFieldP
  -> (forall x y :e R, zero < x -> zero <= y -> exists n :e N, y <= n * x)
  -> (forall a b :e R :^: N,
        (forall n :e N, a n <= b n /\ a n <= a (n + one) /\ b (n + one) <= b n)
     -> exists x :e R, forall n :e N, a n <= x /\ x <= b n)
  -> q)
 -> RealsP -> q.

End RealsP.

Section FieldP_transfer.

Variable R : set.

Variable zero one : set.
Variable plus mult : set -> set -> set.

Infix + 360 right := plus.
Infix * 355 right := mult.

Variable R' : set.

Variable zero' one' : set.
Variable plus' mult' : set -> set -> set.

Infix :+: 360 right := plus'.
Infix :*: 355 right := mult'.

Variable f:set -> set.

Axiom FieldP_transfer: FieldP R zero one plus mult
 -> bij R R' f
 -> f zero = zero'
 -> f one = one'
 -> (forall x y :e R, f (x + y) = f x :+: f y)
 -> (forall x y :e R, f (x * y) = f x :*: f y)
 -> FieldP R' zero' one' plus' mult'.

Variable leq : set -> set -> prop.

(* Unicode <= "2264" *)
Infix <= 490 := leq.

Variable leq' : set -> set -> prop.

End FieldP_transfer.

Section OrderedFieldP_transfer.

Variable R : set.

Variable zero one : set.
Variable plus mult : set -> set -> set.

Infix + 360 right := plus.
Infix * 355 right := mult.

Variable leq : set -> set -> prop.

(* Unicode <= "2264" *)
Infix <= 490 := leq.

Variable R' : set.

Variable zero' one' : set.
Variable plus' mult' : set -> set -> set.

Infix :+: 360 right := plus'.
Infix :*: 355 right := mult'.

Variable leq' : set -> set -> prop.

Variable f:set -> set.

Axiom OrderedFieldP_transfer : OrderedFieldP R zero one plus mult leq
 -> bij R R' f
 -> f zero = zero'
 -> f one = one'
 -> (forall x y :e R, f (x + y) = f x :+: f y)
 -> (forall x y :e R, f (x * y) = f x :*: f y)
 -> (forall x y :e R, x <= y <-> leq' (f x) (f y))
 -> OrderedFieldP R' zero' one' plus' mult' leq'.

End OrderedFieldP_transfer.

Section RealsP_transfer.

Variable R : set.

Variable zero one : set.
Variable plus mult : set -> set -> set.

Infix + 360 right := plus.
Infix * 355 right := mult.

Variable leq : set -> set -> prop.

(* Unicode <= "2264" *)
Infix <= 490 := leq.

Variable R' : set.

Variable zero' one' : set.
Variable plus' mult' : set -> set -> set.

Infix :+: 360 right := plus'.
Infix :*: 355 right := mult'.

Variable leq' : set -> set -> prop.

Variable f:set -> set.

Axiom RealsP_transfer : RealsP R zero one plus mult leq
 -> bij R R' f
 -> f zero = zero'
 -> f one = one'
 -> (forall x y :e R, f (x + y) = f x :+: f y)
 -> (forall x y :e R, f (x * y) = f x :*: f y)
 -> (forall x y :e R, x <= y <-> leq' (f x) (f y))
 -> RealsP R' zero' one' plus' mult' leq'.

End RealsP_transfer.

Section ComplexP.

Variable C : set.

Variable Re Im : set -> set.
Variable zero one i : set.
Variable plus mult : set -> set -> set.

Infix + 360 right := plus.
Infix * 355 right := mult.

Let R := {z :e C | Re z = z}.

(* Parameter ComplexP "8d03ffa66c36a375acccc24b9221193d63a739a47abf4c40d0447fb3d4f9dcf3" "abe2eaeb508bc5356373b0d3b04e34492403a50eb13f0bbab79cdb1d514ab2ce" *)
Parameter ComplexP : prop.

Axiom ComplexP_I : FieldP C zero one plus mult
 -> (exists leq:set -> set -> prop, RealsP R zero one plus mult leq)
 -> (forall z :e C, Im z :e R)
 -> (i :e C)
 -> (forall z :e C, Re z :e C)
 -> (forall z :e C, Im z :e C)
 -> (forall z :e C, z = Re z + i * Im z)
 -> (forall z w :e C, Re z = Re w -> Im z = Im w -> z = w)
 -> (i * i + one = zero)
 -> ComplexP.

End ComplexP.

Section SurrealArithmetic.

(* Parameter minus_SNo "12f05b568c0f56f989dc6a0c5648798ad4485d3e81e8996637959f85a4e60e05" "1dbc83d062a14f03e92712bfb015aa79e740ba08210afca796abeb87d2a21d6d" *)
Parameter minus_SNo : set -> set.

Prefix - 358 := minus_SNo.

Axiom minus_SNo_eq : forall x, SNo x -> - x = SNoCut {- z|z :e SNoR x} {- w|w :e SNoL x}.

Axiom minus_SNo_prop1 : forall x, SNo x -> SNo (- x) /\ (forall u :e SNoL x, - x < - u) /\ (forall u :e SNoR x, - u < - x) /\ SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
Axiom SNo_minus_SNo : forall x, SNo x -> SNo (- x).
Axiom minus_SNo_Lt_contra : forall x y, SNo x -> SNo y -> x < y -> - y < - x.
Axiom minus_SNo_Le_contra : forall x y, SNo x -> SNo y -> x <= y -> - y <= - x.
Axiom minus_SNo_SNoCutP : forall x, SNo x -> SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
Axiom minus_SNo_SNoCutP_gen : forall L R, SNoCutP L R -> SNoCutP {- z|z :e R} {- w|w :e L}.
Axiom minus_SNo_Lev_lem1 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, SNoLev (- x) c= SNoLev x.
Axiom minus_SNo_Lev_lem2 : forall x, SNo x -> SNoLev (- x) c= SNoLev x.
Axiom minus_SNo_invol : forall x, SNo x -> - - x = x.
Axiom minus_SNo_Lev : forall x, SNo x -> SNoLev (- x) = SNoLev x.
Axiom minus_SNo_SNo_ : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNo_ alpha (- x).
Axiom minus_SNo_SNoS_ : forall alpha, ordinal alpha -> forall x, x :e SNoS_ alpha -> - x :e SNoS_ alpha.
Axiom minus_SNoCut_eq_lem : forall v, SNo v -> forall L R, SNoCutP L R -> v = SNoCut L R -> - v = SNoCut {- z|z :e R} {- w|w :e L}.
Axiom minus_SNoCut_eq : forall L R, SNoCutP L R -> - SNoCut L R = SNoCut {- z|z :e R} {- w|w :e L}.
Axiom minus_SNo_Lt_contra1 : forall x y, SNo x -> SNo y -> -x < y -> - y < x.
Axiom minus_SNo_Lt_contra2 : forall x y, SNo x -> SNo y -> x < -y -> y < - x.
Axiom minus_SNo_Lt_contra3 : forall x y, SNo x -> SNo y -> -x < -y -> y < x.
Axiom minus_SNo_0 : - 0 = 0.
Axiom SNo_momega : SNo (- omega).
Axiom mordinal_SNo : forall alpha, ordinal alpha -> SNo (- alpha).
Axiom mordinal_SNoLev : forall alpha, ordinal alpha -> SNoLev (- alpha) = alpha.
Axiom mordinal_SNoLev_min : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> - alpha < z.
Axiom mordinal_SNoLev_min_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> - alpha <= z.

(* Parameter add_SNo "cc4158122f794f7a188c196719c6c4dc8e69cea21aaa898aa886a389ba38744d" "352725a851dcf13f3bc34e1a28c8845302c44e6ee9c63b84f620fc8ccf1a6c7e" *)
Parameter add_SNo : set -> set -> set.

Infix + 360 right := add_SNo.

Axiom add_SNo_eq : forall x, SNo x -> forall y, SNo y ->
    x + y = SNoCut ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).

Axiom add_SNo_prop1 : forall x y, SNo x -> SNo y ->
    SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).

Axiom SNo_add_SNo : forall x y, SNo x -> SNo y -> SNo (x + y).

Axiom add_SNo_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x < z -> x + y < z + y.

Axiom add_SNo_Le1 : forall x y z, SNo x -> SNo y -> SNo z -> x <= z -> x + y <= z + y.

Axiom add_SNo_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> y < z -> x + y < x + z.

Axiom add_SNo_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> y <= z -> x + y <= x + z.

Axiom add_SNo_Lt3a : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y <= w -> x + y < z + w.

Axiom add_SNo_Lt3b : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y < w -> x + y < z + w.

Axiom add_SNo_Lt3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y < w -> x + y < z + w.

Axiom add_SNo_Le3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y <= w -> x + y <= z + w.

Axiom add_SNo_SNoCutP : forall x y, SNo x -> SNo y -> SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).

Axiom add_SNo_SNoCutP_gen : forall Lx Rx Ly Ry, SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> SNoCutP ({w + SNoCut Ly Ry|w :e Lx} :\/: {SNoCut Lx Rx + w|w :e Ly})
            ({z + SNoCut Ly Ry|z :e Rx} :\/: {SNoCut Lx Rx + z|z :e Ry}).

Axiom add_SNo_com : forall x y, SNo x -> SNo y -> x + y = y + x.

Axiom add_SNo_0L : forall x, SNo x -> 0 + x = x.

Axiom add_SNo_0R : forall x, SNo x -> x + 0 = x.

Axiom add_SNo_minus_SNo_linv : forall x, SNo x -> -x+x = 0.

Axiom add_SNo_minus_SNo_rinv : forall x, SNo x -> x + -x = 0.

Axiom add_SNo_ordinal_SNoCutP : forall alpha, ordinal alpha -> forall beta, ordinal beta -> SNoCutP ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.

Axiom add_SNo_ordinal_eq : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + beta = SNoCut ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.

Axiom add_SNo_ordinal_ordinal : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordinal (alpha + beta).

Axiom add_SNo_ordinal_SL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordsucc alpha + beta = ordsucc (alpha + beta).

Axiom add_SNo_ordinal_SR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + ordsucc beta = ordsucc (alpha + beta).

Axiom add_SNo_ordinal_InL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e alpha, gamma + beta :e alpha + beta.

Axiom add_SNo_ordinal_InR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e beta, alpha + gamma :e alpha + beta.

Axiom add_nat_add_SNo : forall n m :e omega, add_nat n m = n + m.

Axiom add_SNo_In_omega : forall n m :e omega, n + m :e omega.

Axiom add_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x + y), (exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v).

Axiom add_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x + y), (exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u).

Axiom add_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z -> x + (y + z) = (x + y) + z.

Axiom add_SNo_cancel_L : forall x y z, SNo x -> SNo y -> SNo z -> x + y = x + z -> y = z.

Axiom add_SNo_cancel_R : forall x y z, SNo x -> SNo y -> SNo z -> x + y = z + y -> x = z.

Axiom minus_add_SNo_distr : forall x y, SNo x -> SNo y -> -(x+y) = (-x) + (-y).

Axiom add_SNo_Lev_bd : forall x y, SNo x -> SNo y -> SNoLev (x + y) c= SNoLev x + SNoLev y.
Axiom add_SNo_SNoS_omega : forall x y :e SNoS_ omega, x + y :e SNoS_ omega.

(* Parameter mul_SNo "0ea81ebfa1c27bc09304df458175ee1baa8cd7e5182011b1dd57da69a62c91c0" "79af301da31991b30310895c394d3c295e82a6b52761167e622f985daad2f3a9" *)
Parameter mul_SNo : set -> set -> set.

Infix * 355 right := mul_SNo.

Axiom mul_SNo_eq : forall x, SNo x -> forall y, SNo y ->
   x * y
      = SNoCut ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoR y})
               ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoL y}).

Definition div_SNo : set -> set -> set := fun x y => if y = 0 then 0 else the (fun z => SNo z /\ z * y = x).

Infix :/: 353 := div_SNo.

End SurrealArithmetic.

Definition real : set := the (fun R => (forall x :e R, SNo x) /\ RealsP R 0 1 add_SNo mul_SNo SNoLe).

Definition CSNo : set -> prop := fun z => exists x, SNo x /\ exists y, SNo y /\ z = SNo_pair x y.

Axiom CSNo_I : forall x y, SNo x -> SNo y -> CSNo (SNo_pair x y).
Axiom CSNo_E : forall z, CSNo z ->
  forall p:set -> prop,
      (forall x y, SNo x -> SNo y -> z = SNo_pair x y -> p (SNo_pair x y))
    -> p z.
Axiom SNo_CSNo : forall x, SNo x -> CSNo x.

Section Complex.

Definition Complex_i : set := SNo_pair 0 1.

Let i := Complex_i.

Axiom SNo_Complex_i : CSNo i.

Definition CSNo_Re : set -> set := fun z => the (fun x => SNo x /\ exists y, SNo y /\ z = SNo_pair x y).
Definition CSNo_Im : set -> set := fun z => the (fun y => SNo y /\ z = SNo_pair (CSNo_Re z) y).

Let Re : set -> set := CSNo_Re.
Let Im : set -> set := CSNo_Im.
Let pa : set -> set -> set := SNo_pair.

Axiom CSNo_Re1: forall z, CSNo z -> SNo (Re z) /\ exists y, SNo y /\ z = pa (Re z) y.
Axiom CSNo_Re2: forall x y, SNo x -> SNo y -> Re (pa x y) = x.
Axiom CSNo_Im1: forall z, CSNo z -> SNo (Im z) /\ z = pa (Re z) (Im z).
Axiom CSNo_Im2: forall x y, SNo x -> SNo y -> Im (pa x y) = y.
Axiom CSNo_ReR: forall z, CSNo z -> SNo (Re z).
Axiom CSNo_ImR: forall z, CSNo z -> SNo (Im z).
Axiom CSNo_ReIm: forall z, CSNo z -> z = pa (Re z) (Im z).
Axiom CSNo_ReIm_split: forall z w, CSNo z -> CSNo w -> Re z = Re w -> Im z = Im w -> z = w.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Definition minus_CSNo : set -> set := fun z => pa (- Re z) (- Im z).
Definition add_CSNo : set -> set -> set := fun z w => pa (Re z + Re w) (Im z + Im w).
Definition mul_CSNo : set -> set -> set := fun z w => pa (Re z * Re w + - (Im z * Im w)) (Re z * Im w + Im z * Re w).
Definition div_CSNo : set -> set -> set := fun x y => if y = 0 then 0 else the (fun z => CSNo z /\ mul_CSNo z y = x).

Axiom CSNo_minus_CSNo : forall z, CSNo z -> CSNo (minus_CSNo z).

Axiom SNo_Re: forall x, SNo x -> Re x = x.

Axiom SNo_Im: forall x, SNo x -> Im x = 0.

Axiom Re_0 : Re 0 = 0.

Axiom Im_0 : Im 0 = 0.

Axiom Re_1 : Re 1 = 1.

Axiom Im_1 : Im 1 = 0.

Axiom Re_i : Re i = 0.

Axiom Im_i : Im i = 1.

Axiom add_SNo_add_CSNo : forall x y, SNo x -> SNo y -> x + y = add_CSNo x y.

Axiom CSNo_add_CSNo : forall z w, CSNo z -> CSNo w -> CSNo (add_CSNo z w).

Axiom add_CSNo_0L : forall z, CSNo z -> add_CSNo 0 z = z.

Axiom add_CSNo_0R : forall z, CSNo z -> add_CSNo z 0 = z.

Axiom add_CSNo_minus_CSNo_linv : forall z, CSNo z -> add_CSNo (minus_CSNo z) z = 0.

Axiom add_CSNo_minus_CSNo_rinv : forall z, CSNo z -> add_CSNo z (minus_CSNo z) = 0.

Axiom minus_SNo_minus_CSNo : forall x, SNo x -> - x = minus_CSNo x.

End Complex.

Definition complex : set := ReplSep2 real (fun _ => real) (fun _ _ => True) SNo_pair.

Section Complex.

Prefix - 358 := minus_CSNo.
Infix + 360 right := add_CSNo.
Infix * 355 right := mul_CSNo.
Infix :/: 353 := div_CSNo.

Definition int : set := omega :\/: {- n|n :e omega}.
Definition rat : set := ReplSep2 int (fun _ => omega) (fun num den => den <> 0) (fun num den => num :/: den).

Definition Sum : set -> set -> (set -> set) -> set
 := fun m n f =>
      nat_primrec 0 (fun k r => if k :e m then 0 else f k + r) (ordsucc n).

Definition Prod : set -> set -> (set -> set) -> set
 := fun m n f =>
      nat_primrec 1 (fun k r => if k :e m then 1 else f k * r) (ordsucc n).

End Complex.

